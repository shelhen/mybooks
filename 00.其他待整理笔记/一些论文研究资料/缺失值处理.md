# 数据缺失值处理

## 1. 理解数据缺失

数据处理作为实证分析的基础，是一个十分繁琐的过程。我们搜集来的数据 (尤其是问卷调查数据) 往往存在各式各样的问题，其中最主要的问题之一就是存在缺失数据 (Missing data)。

如何更好的应对数据缺失的问题呢？本文将从数据缺失背后的理论机制讲起，作为 “数据缺失与多重插补” 专题的第一篇推文，力求帮助大家深入浅出地理解缺失数据的处理方法。

**数据缺失的定义**：

- 数据缺失 (Missing data) 是指那些实际未观测到，但是如果观测到会有意义的值。也就是说，缺失数据隐藏了有价值的信息。更直白点讲，计划收集用于研究，但未收集到的数据均可看作缺失数据。

**数据缺失的原因**：

- 信息未被采集到；
- 信息被采集后丢失；
- 信息被采集后认定有误并被删除。

**数据缺失的影响**：

- 削弱数据能效 (reduce power)；
- 分析过程中需要缺失数据满足相应假设 (analysis requires untestable assumptions)；
- 错误的假设可能导致结果偏误 (wrong assumptions can lead to bias)。

## 2. 数据缺失模式与机制

处理缺失数据的关键在于识别不同类型的缺失数据，针对不同类型的缺失数据，采用相匹配的处理方法。本小节从数据缺失模式 (pattern) 和数据缺失机制 (mechanism) 两方面进行讲解。

### 2.1 数据缺失常见模式

数据缺失模式 (missing data pattern) 是指在一个数据集中，数据观测值和数据缺失值的结构。其中最常见的模式有以下三种：

- 单一模式 (Univariate Pattern)：缺失值均属于同一个变量；
- 单调模式 (Monotone Pattern)：典型的面板数据中被调查对象退出调查且后续不再返回；
- 一般模式 (General Pattern)：缺失值在数据集中随机散布。

下图展示了三种不同的缺失数据模式，其中灰色部分表示数据缺失。

![图 1：常见缺失数据模式](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E4%B8%8E%E5%A4%9A%E9%87%8D%E6%8F%92%E8%A1%A51_Fig1_Pattern_%E5%AD%9F%E4%BD%B3%E9%9F%B3.png)

在 Stata 中，可用如下命令识别缺失数据：

```stata
misstable summarzie, gen (m_)
tab m_*
misstable pattern
misstable pattern, freq
```

### 2.2 数据缺失机制

Rubin (1976) 提出了被广为认可的数据缺失机制，用来描述缺失值存在的概率与数据的关系。他将缺失数据分为如下三种：

- 完全随机缺失数据 (Missing Completely at Random Data，MCAR)：数据缺失的概率与数据集中的任何数据均无关；
- 随机缺失数据 (Missing at Random Data，MAR)：变量 **Y** 数据缺失的概率与模型中其他变量相关，但与变量 **Y** 本身无关；
- 非随机缺失数据 (Missing Not at Random Data，MNAR): 变量 **Y** 数据缺失的概率即使在控制其他变量以后，仍与 **Y** 本身有关。

由于这个定义容易让人产生混淆，本节内容借鉴 Enders (2010) 的做法，引入一个简单的例子进行概念描述。我们模拟一个员工试用期表现得分 (job performance rating)，并与员工 IQ 测试得分 (IQ) 进行比较。下图展示了完全数据 (complete)、完全随机缺失数据 (MCAR)、随机缺失数据 (MAR) 和非随机缺失数据 (MNAR) 四种情况。

![图 2：数据缺失模式举例](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E4%B8%8E%E5%A4%9A%E9%87%8D%E6%8F%92%E8%A1%A51_Fig2_Mechanism_%E5%AD%9F%E4%BD%B3%E9%9F%B3.png)

图中 MCAR 列表示的缺失数据是完全随机的；MAR 列表示的缺失数据只与 IQ 得分有关，IQ 得分低的数据存在缺失；MNAR 列表示的缺失数据与员工试用期表现得分本身相关，表现得分低的数据存在缺失。

## 3. 处理数据缺失的传统方式

常用的缺失数据处理方法可以总结成两大类，分别为直接删除法 (Deletion Method) 和单一插补法 (Single Imputation Method)。本节内容对两种常见方法进行简单的介绍，每种方法均有其适用情景以及相对应的优缺点。

### 3.1 直接删除法

直接删除法中最常用的方法为成列删除和成对删除：

- 成列删除 (Listwise Deletion, Complete-Case Analysis)：删除所有存在缺失值的个体；
- 成对删除 (Pairwise Deletion, Available-Case Analysis)：只删除需要用到的变量存在缺失值的个体。

直接删除法简单、易操作，但是它们要求缺失数据是「完全随机缺失数据 (MCAR)」，否则会产生明显的偏误。此外，即使缺失数据满足 MCAR 条件，直接删除法会造成数据的浪费，大大削弱分析的效能 (reduce power)。

### 3.2 单一插补法

单一插补 (Single Imputation) 名称的由来是因为这些方法为每个缺失的数据点生成一个单一的替换值，与多重插补 (Multiple Imputation) 是不同的。多重插补是创建数据集的多个副本，并对每个副本使用不同的估计方法来估算缺失值。本文只简单列举单一插补法中的不同方法，不做展开，有兴趣的读者可以参考 Enders (2010)。

- 算术平均插补法 (Arithmetic Mean Imputation)；
- 回归插补法 (Regression Imputation)；
- 随机回归插补法 (Stochastic Regression Imputation)。

单一插补法的优势在于创建了完整的数据集，使那些在直接删除法中会被删除的数据得以利用。但是大部分单一插补法，即使在缺失数据是 MCAR 的情况下，均会产生有偏估计 (随即回归插补是例外，其是唯一可以对 MAR 数据产生无偏估计的方法)。此外，单一回归插补法会使「标准误被低估，导致置信区间过窄」。

## 4. 多重插补初探

多重插补法 (Multiple Imputation) 为单一插补法下的标准误低估问题提供了一个解决方案。其可以通过引入观测数据的可变性、估计插补模型的不确定性和生成插补值的不确定性增加数据的标准误。多重插补的理论源于是单一插补法中的随机回归插补，但是其数学基础来自贝叶斯估计。多重插补 (MI) 一般涉及以下三个步骤：

- 插补阶段 (Imputation Phase)：创建数据集的 m 个副本，每个副本中包含对缺失值的不同估计；
- 分析阶段 (Analysis Phase)：将分析模型拟合到 m 个数据集中；
- 汇集阶段 (Pooling Phase)：使用 Rubin 法则将 m 组结果汇集成一个结果。

![图 3：多重插补步骤](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E4%B8%8E%E5%A4%9A%E9%87%8D%E6%8F%92%E8%A1%A51_Fig3_Step_%E5%AD%9F%E4%BD%B3%E9%9F%B3.png)

Stata 中多重插补的操作可使用如下命令：

```stata
*准备工作
mi set flong/mlong/wide //为 MI 声明数据结构
mi register imputed     //声明要插补的变量

*插补阶段
mi impute regress/logit        //单一插补法
mi impute monotone/mvn/chained //多重插补法

*分析与汇集阶段
mi estimate  //分析并整合结果
```



## 5. 参考资料

- Little, R. J., & Rubin, D. B. 2019. Statistical analysis with missing data (Vol. 793). John Wiley & Sons. [-Book-](https://onlinelibrary.wiley.com/doi/book/10.1002/9781119013563)
- Enders, C. K. 2010. Applied missing data analysis. Guilford press. [-Book-](https://books.google.co.uk/books?hl=zh-CN&lr=&id=5o-yNRJTQ1EC&oi=fnd&pg=PP2&ots=n-IhS0ImZk&sig=gGvBmuzj0XHyx48LGg4bAylViBs&redir_esc=y#v=onepage&q&f=false)
- Rubin, D. B. 1976. Inference and missing data. Biometrika, 63(3), 581-592. [-PDF-](https://doi.org/10.1093/biomet/63.3.581)
- University College London PhD Course: Missing Data and Multiple Imputation for Cross-Sectional and Longitudinal Data



## 1. 多重插补知识点总结

### 1.1 多重插补简要回顾

> 在数据缺失与多重插补专题系列的第一篇推文 （[缺失值与多重补漏分析（一）](https://www.lianxh.cn/details/694.html)）中，我们较为详细的介绍了数据缺失的相关知识，并引出了运用多重插补方法处理数据缺失。下面我们简要回顾一下有关多重插补的知识点。

多重插补 (Multiple Imputation) 的思想来源于贝叶斯估计，其认为待插补的 **缺失值是随机的 (MAR)** ，它的值来自于已观测到的值。在具体操作上，是通过创建数据集的 m 个副本 （m 的个数通常为 3-10 个；目前实际操作中 m 也时常取值为 20），对每个副本使用不同的估计方法估算出缺失值，而后将模型拟合到 m 个数据集中，最后运用 Rubin 法则整合为一个结果。

- 插补过程独立重复 m 次
- 每个数据集均由观测值和缺失值的插补组成
- 每个数据集对缺失值有不同的独立插补集
- 插补的 m 个数据集的差异性 (variability) 反映了插补的不确定性 (uncertainty)
- 多重插补通过恢复缺失数据的原始可变性，并通过纳入由插补缺失数据引起的不确定性来解释缺失数据

### 1.2 如何进行多重插补

#### 1.2.1 多重插补法的实现阶段

- 插补阶段 (Imputation Phase): 用估计值填补缺失数据从而创建完整的数据集。这个过程重复 m 次以创建 m 个插补数据集。
- 分析阶段 (Analysis Phase): 将分析模型拟合到 m 个数据集中。
- 汇集阶段 (Pooling Phase)：使用 Rubin 法则将 m 组结果汇集成一个结果。

#### 1.2.2 多重插补的操作步骤

- (1) 定义回归模型 (analysis model)
- (2) 查看数据缺失数量和数据缺失模式 (pattern)
- (3) 识别完全变量 (fully observed)、缺失变量和潜在辅助变量 (auxiliary variables)：辅助变量指可以使 MAR （随机缺失数据）假设更合理的变量，帮助减小偏差，提高估计精度
- (4) 使用所选择的方法执行多重插补 （本文只介绍 MVN 和 MICE）
- (5) 将回归模型拟合到插补数据中
- (6) 进行插补诊断 (imputation diagnostics)

### 1.3 多重插补的常用方法

据上文所述，进行多重插补的第 (4) 步是选择合适的插补方法，本文以重点讲述以下两种插补方法：

- MVN (Multivariate Normal Regression)
- MICE (Multiple Imputation by Chained Equations) / FCS (Fully Conditional Specification)

 

## 2. MVN 方法介绍

MVN (Multivariate Normal Regression) 多元正态回归方法假设插补模型中的所有变量遵循联合多元正态分布 (joint multivariate normal distribution)，并使用数据增广 (data augmentation, DA) 方法 —— 一种马尔可夫链蒙特卡洛 Markov chain Monte Carlo (MCMC) 运算，在多元正态分布假设下估算缺失数据。

MVN 方法下回归是线性的，适用于连续变量 (continuous variables)，而当缺失数据中存在二元变量 (binary variables) 和分类变量 (categorical variables) 时，该方法的假设条件不再适用。但是已有研究表明，当二元变量和分类变量数据中不存在严重偏斜 (severly skewed) 时，MVN 方法依然可以得到较好的运用。

### 2.1 MVN 方法理论概要

MVN 方法最初由 Schafer (1997) 实现。本文将多重插补 MVN 方法的重点概括如下：

- 在 MVN 插补模型中，同时使用线性回归模型对缺失数据进行插补，其中每个变量都可能依赖于所有其他变量
- MVN 方法通过数据增广 (DA) 马尔可夫链蒙特卡洛 (MCMC) 过程实现
- 数据增广 (DA) 算法通过缺失数据的多元正态分布假设进行插补运算
- MVN 方法适用于连续变量 (continuous variables)
- 若变量存在偏斜 (skewed)，将其转换为近似正态分布，进行估算后再转回
- 若缺失数据为二元或有序变量 (binary / ordinal variables), 插补结果四舍五入到最近的类别中

### 2.2 MVN 方法 Stata 命令

本节所展示的 Stata 命令根据本推文 1.2.2 节 “多重插补的操作步骤” 的顺序书写。首先，设定好回归模型，我们以线性回归 `regress` 为例。使用 MVN 方法进行多重插补的具体操作命令如下所示：

```stata
*定义回归模型
. regress varlist //设定模型为线性回归
*查看数据缺失数量和缺失模式
. mi set flong/mlong/wide //为 MI 声明数据结构
. mi misstable summarize varlist //查看缺失数据
*指定完全变量和要插补的变量
. mi register imputed varlist  //声明要插补的变量
. mi register regular varlist  //声明不含缺失值的变量
*选择 MVN 方法进行多重插补
. mi impute mvn ivars [= indepvars] [if] [, impute_options options]  //声明使用 MVN 方法
*将回归模型拟合到插补数据中
. mi estimate: regress varlist    //以线性回归模型为例
. mi estimate, vartable nocitable //显示插补的方差信息
```

 

## 3. MICE 方法介绍

MICE (Multiple Imputation by Chained Equations) 通过链式方程进行的多重插补又被称为 Fully Conditional Specification (FCS) 全条件定义法，或者 Sequential Regression Multiple Imputation （顺序回归多重插补）。

MICE 方法最初由 van Buuren, Boshuizen, 和 Knook (1999) 提出并应用于生存分析中。其与 MVN 方法的本质区别是在进行插补时，不必考虑变量的联合分布，而是利用单个变量的条件分布 (univariate conditional distributions) 逐一进行插补。这意味着每个变量都可以根据其自身分布建模，比如使用逻辑回归 (logistic regression) 建模的二元变量 (binary variables) 和使用线性回归 (linear regression) 建模的连续变量 (continuous variables) 等。

### 3.1 MICE 方法理论概要

MICE 方法在实际操作中比 MVN 方法运用更为广泛，本节将多重插补 MICE 方法的重点概括如下：

- MICE 方法不要求缺失变量遵循联合分布 (joint distribution)
- MICE 方法不要求变量缺失模式为单调模式 (monotone pattern)
- MICE 方法利用单个变量的条件分布 (univariate conditional distributions) 进行插补
- MICE 方法可以为每个变量指定不同的回归模型
- MICE 方法是一个迭代过程 (iterative procedure)，因此必须评估其收敛性 (convergence)

### 3.2 MICE 方法 Stata 命令

MICE 在 Stata 中可用的回归模型有：二元、有序和多类逻辑回归 (binary, ordered, and multinomial logistic regression)，线性回归 (linear regression)，泊松和负二项回归 (poisson and negative binomial regression)。其中，线性回归是默认模式。

本节所展示的 Stata 命令根据本推文 1.2.2 节 “多重插补的操作步骤” 的顺序书写。由于 MICE 方法可以为不同类型的缺失变量指定不同的回归模型，为了展示方便，假设两个含有缺失值的变量 **var1**, **var2** 分别为连续变量和分类变量。设定好回归模型，我们以线性回归 `regress` 为例。使用 MICE 方法进行多重插补的具体操作命令如下所示：

```Stata
*定义回归模型
. regress varlist //设定模型为线性回归
*查看数据缺失数量和缺失模式
. mi set flong/mlong/wide //为 MI 声明数据结构
. mi misstable summarize varlist //查看缺失数据 
*指定完全变量和要插补的变量
. mi register imputed varlist  //声明要插补的变量
. mi register regular varlist  //声明不含缺失值的变量
*选择 MICE 方法进行多重插补
. mi impute chained (ologit) var2 (regress) var1 [= indepvars] [if] [weight] [, impute_options options] //为不同种类缺失变量指定不同的回归模型
*将回归模型拟合到插补数据中
. mi estimate: regress varlist    //以线性回归模型为例
. mi estimate, vartable nocitable //显示插补的方差信息
```

 

## 4. 总结与补充

### 4.1 MVN 方法与 MICE 方法比较

MVN 方法与 MICE 方法均为多重插补中的常用方法，根据上文的讲解，相信大家对这两种方法的适用条件以及操作方法都有了比较全面的了解。现将两种方法的比较总结如下：

- MVN 方法基于联合多元正态分布 (joint multivariate normal distribution) 建模；MICE 方法基于单个变量的条件分布 (univariate conditional distributions) 进行逐一插补
- MVN 方法适用于连续变量；MICE 方法可以处理多种类型的变量
- MICE 方法使用逐一插补 (variable-by-variable specification) ，这使其能够为多个变量构建复杂的插补模型

可以看出，MICE 方法的适用范围比 MVN 方法更广，在实际操作中也更受欢迎。

### 4.2 单调缺失数据 (Monotone Pattern) 的插补

在上一篇推文中我们详细讲述了数据缺失模式 (Missing Data Pattern), 其中单调缺失模式 (Monotone Pattern) 如下图所示，指变量 Y1, Y2, Y3, Y4 的缺失值数量呈现单调递增状态。

![单调缺失模式](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E4%B8%8E%E5%A4%9A%E9%87%8D%E6%8F%92%E8%A1%A52_Fig1_Monotone_%E5%AD%9F%E4%BD%B3%E9%9F%B3.png)



当缺失数据为单调缺失模式时，除了 MVN 方法和 MICE 方法外，我们还可以调用 `mi impute monotone` 命令对缺失数据进行插补，详情请参考 `help mi impute monotone`。在实际操作中单调缺失数据模式并不常见，所以本文不再对此详细展开，有兴趣的学友们可以自行学习。

 

## 5. 参考资料

- Kropko, J., Goodrich, B., Gelman, A., & Hill, J. 2014. Multiple imputation for continuous and categorical data: comparing joint multivariate normal and conditional approaches. Political Analysis, 22(4). [-PDF-](https://www.cambridge.org/core/services/aop-cambridge-core/content/view/CDC454BAEB65A51102543ACF0BD162F6/S1047198700013802a.pdf)
- Lee, K. J., & Carlin, J. B. 2010. Multiple imputation for missing data: fully conditional specification versus multivariate normal imputation. American journal of epidemiology, 171(5), 624-632. [-PDF-](https://academic.oup.com/aje/article/171/5/624/137388?login=true)
- Schafer, J. L. 1997. Analysis of incomplete multivariate data. CRC press. [-Book-](https://www.taylorfrancis.com/books/mono/10.1201/9780367803025/analysis-incomplete-multivariate-data-schafer)
- Azur, M. J., Stuart, E. A., Frangakis, C., & Leaf, P. J. 2011. Multiple imputation by chained equations: what is it and how does it work?. International journal of methods in psychiatric research, 20(1), 40-49. [-PDF-](https://onlinelibrary.wiley.com/doi/epdf/10.1002/mpr.329)
- Royston, P. 2004. Multiple imputation of missing values. The Stata Journal, 4(3), 227-241. [-PDF-](https://journals.sagepub.com/doi/pdf/10.1177/1536867X0400400301)
- Little, R. J., & Rubin, D. B. 2019. Statistical analysis with missing data (Vol. 793). John Wiley & Sons. [-Book-](https://onlinelibrary.wiley.com/doi/book/10.1002/9781119013563)
- Enders, C. K. 2010. Applied missing data analysis. Guilford press. [-Book-](https://books.google.co.uk/books?hl=zh-CN&lr=&id=5o-yNRJTQ1EC&oi=fnd&pg=PP2&ots=n-IhS0ImZk&sig=gGvBmuzj0XHyx48LGg4bAylViBs&redir_esc=y#v=onepage&q&f=false)
- Rubin, D. B. 1976. Inference and missing data. Biometrika, 63(3), 581-592. [-PDF-](https://doi.org/10.1093/biomet/63.3.581)
- University College London PhD Course: Missing Data and Multiple Imputation for Cross-Sectional and Longitudinal Data

## 1. 确保插补模型的兼容性

插补模型与分析模型之间的兼容性 (Compatibility)， 是确保多重插补有效性 (validity) 的关键因素之一。

### 1.1 什么是兼容性？

插补模型与分析模型兼容指两者存在联合分布 (joint distribution)，意味着插补模型和分析模型是条件分布 (conditional distribution)。下面我们用数学公式举例：

假设两个变量 X 和 Y，其中 X 是包含缺失数据的协变量 (covariate variable)；Y 是完整的，不含缺失数据的因变量 (dependent variable)。

> 协变量 (covariate variables)：任何可测量并被认为与因变量 (dependent variables) 具有统计关系的变量都可以作为潜在协变量。换句话说，协变量是因变量可能的预测或解释变量。在回归分析中，自变量（即回归量）有时被称为协变量，此时，协变量是最重要的。 然而在大多数其他情况下，与自变量相比，协变量并不是最重要的，它们的出现是因为实验或观察单位是异质的。

令 YY 与 XX 符合下列二元正态分布 (Bivariate Normal Distribution, BNV)

(��)∼BVN[(����),(��2������������2)](*Y**X*)∼BVN[(*μ**Y**μ**X*),(*σ**Y*2*ρ**σ**Y**σ**X**ρ**σ**Y**σ**X**σ**X*2)]

分析模型 (Y(Y 对 XX 的线性回归) 可以作为条件分布从该上述联合分布中导出：

�∣�∼�[��+�����(�−��),��2(1−�2)]*Y*∣*X*∼*N*[*μ**Y*+*ρ**σ**X**σ**Y*(*X*−*μ**X*),*σ**Y*2(1−*ρ*2)]

相似的，变量 XX 的插补模型 （X（X 对 YY 的线性回归) 也可以导出条件分布：

�∣�∼�[��+�����(�−��),��2(1−�2)]*X*∣*Y*∼*N*[*μ**X*+*ρ**σ**Y**σ**X*(*Y*−*μ**Y*),*σ**X*2(1−*ρ*2)]

因此，分析模型与插补模型是兼容的。

### 1.2 插补模型的变量选择

在实际操作中，兼容性意味着插补模型应保留分析模型中的所有结构。插补模型中需要包含：

- 分析模型中包括因变量在内的所有变量
- 其他潜在的辅助变量 (auxiliary variables)
- 体现出分析模型中协变量之间的交互作用或非线性关系（若存在）

(1) 当插补模型包含除分析模型的额外项 （例如辅助变量或增加一些交互项）时：

- 若为正确的额外项，则插补模型的偏差 (bias) 减小，精度 (precision) 提升
- 若为错误的额外项，分析不会产生偏差，但可能会导致更大的标准误 (standard errors)

(2) 当插补模型从分析模型中排除一些项时：

- 若为正确排除，插补模型将会很高效 (Rubin, 1996)，但这种操作实际中几乎不存在
- 若为错误排除，插补模型会产生明显偏差 (typically biased)

模型中辅助变量的选取应考虑以下几点 (Carpenter & Kenward, 2013)：

> 辅助变量 (auxiliary variables) 指的是未包含在分析模型中，但是与含有缺失值的目标变量有联系的变量，或者是能够使随机缺失 (MAR) 假设更合理的变量。

- 能同时预测缺失 (missingness) 和缺失值 (missing values) 的变量应作为插补模型的辅助变量，以减少偏差
- 仅预测缺失值 (missing values) 的变量可以提高效率，但对偏差无影响
- 仅预测缺失 (missingness) 的变量不会提供额外信息，不应作为辅助变量

 

## 2. 插补次数与模型检验

### 2.1 插补次数 (m) 的选择

传统的观点认为，考虑到多重插补的效率，m 的取值在 3 到 10 之间。但是如果希望得到较为稳定的标准误 (SE)，则需要增加插补的次数。最近根据再现性 (Reproducibility) 观点认为，m 的取值应使蒙特卡洛误差足够小，以便于结果的再现 (White, Royston & Wood, 2011)。

> 蒙特卡洛误差 (Monte Carlo Error) 是使用相同数据，重复运行相同插补程序的估计标准误。随着 m 的增加，蒙特卡洛误差趋于 0。较小的蒙特卡洛误差可以确保插补结果的稳定。**经验法则认为 m 应大于数据集中不完整个体 (incomplete case) 的占比**。

### 2.2 模型的检验

随着多重插补在数据处理中的广泛应用，检验多重插补的有效性显得愈发重要。在实际操作中，插补模型和分析模型都需要被检验，而且对分析模型检验的重要性与对插补模型检验的重要性旗鼓相当。

简单方法是在每个插补后的完整数据集中进行模型检验，并报告检查结果。估算每个完整数据集中的残差，并绘制 **残差图**。

 

## 3. 插补操作常见问题

### 3.1 非正态分布

之前我们介绍了 MVN 方法和 MICE 方法，利用线性回归对连续变量进行插补。若缺失数据为非正态分布， MVN 方法不再适用。可以用如下方法应对非正态分布：

- 在插补前将非正态分布数据转换为正态分布，插补后再将其反方向转换 （常见的操作例如对 “年龄” 和 “性别” 进行对数变换和逆变换）
- 用 **PMM** (predictive mean matching, 预测均值匹配) 方法进行插补，其中 MICE 方法可以使用 PMM，命令为 `mi impute chained (pmm) ivars`, 具体请见 `help mi impute chained`。

![PMM](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E4%B8%8E%E5%A4%9A%E9%87%8D%E6%8F%92%E8%A1%A53_Fig4_PMM_%E5%AD%9F%E4%BD%B3%E9%9F%B3.png)



### 3.2 非线性

当因变量 Y 与协变量间存在非线性相关关系时，使插补模型与分析模型兼容会变得更加困难。若面对包含因变量 Y 与协变量 X， X2 的回归，可以用以下方法应对非线性关系：

- 忽略 X 与 X2 的关系，将二者视为两个变量，分别进行插补
- 用 **PMM** (predictive mean matching, 预测均值匹配) 方法进行插补，命令为`mi impute chained (pmm) ivars`。

> PMM 方法的操作步骤如下：
>
> - 利用去除缺失值的 X 对 Y 回归，构建插补模型
> - 计算插补模型的系数
> - 利用插补模型的系数和 Y 值预测 X 的缺失值
> - 从无缺失的观测数据中选择离预测值最近的数据作为填充值

### 3.3 交互项

当模型中存在交互项时，MVN 方法不适用，我们可以用 MICE 方法进行插补。举个例子，假设收缩压 (SBP) 与年龄的关系因性别而异，且在数据中有两个个体的年龄和性别均缺失。以 SBP 为因变量，年龄和性别作为两个协变量进行分析，如下图所示。

![交互项](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E4%B8%8E%E5%A4%9A%E9%87%8D%E6%8F%92%E8%A1%A53_Fig5_%E4%BA%A4%E4%BA%92%E9%A1%B9_%E5%AD%9F%E4%BD%B3%E9%9F%B3.png)



```Stata
*MICE 方法交互项
. mi impute chained (logit, include ((sbp*age))) sex (regress, include ((sbp*sex))) age = sbp
```

 

## 4. SMC FCS 方法

上述多重插操作中的常见问题还可以用 SMC FSC 方法处理。SMC FCS (substantive-model compatible fully-conditional specification，实体模型兼容的全条件定义) 方法可以有效的应对非线性和交互项等问题 (Bartlett & Morris, 2015)。

> SMC FCS 方法由 MICE 方法演变而来，其核心思想是强制使插补模型与分析模型兼容。当样本量 n 较小时，SMC FCS 方法能快速得到结果，但当 n 扩大时，其速度逐渐下降。

```Stata
*安装 SMC FCS 命令
. ssc install smcfcs
*针对非线性的命令
. smcfcs regress y x xsq, regress(x) passive(xsq = x^2) m(10)
*针对交互项的命令
. smcfcs regress sbp age sex agesex, regress(age) logit(sex) passive(agesex = age*sex) m(10)
```

 

## 5. 总结

作为数据缺失与多重插补系列的第三篇推文，本文着重讲解了在实际运用多重插补的过程中可能遇到的一些问题，比如非线性和交互项等，以及相应的处理方法。本文的全部讲解基于一个假定条件：模型的因变量不含有缺失数据，而协变量存在缺失数据。对于数据中因变量 Y 含有缺失值的情况，我们并未涉及，有兴趣的学友可以自行查阅相关资料。

 

## 6. 参考资料

- Sterne, J. A., White, I. R., Carlin, J. B., Spratt, M., Royston, P., Kenward, M. G., Wood, A. M., & Carpenter, J. R. 2009. Multiple imputation for missing data in epidemiological and clinical research: potential and pitfalls. Bmj, 338. [-PDF-](https://www.bmj.com/content/338/bmj.b2393/)
- Wood, A. M., White, I. R., & Royston, P. 2008. How should variable selection be performed with multiply imputed data?. Statistics in medicine, 27(17), 3227-3246. [-PDF-](https://onlinelibrary.wiley.com/doi/epdf/10.1002/sim.3177)
- Carpenter, J., & Kenward, M. 2012. Multiple imputation and its application. John Wiley & Sons. [-Book-](https://researchonline.lshtm.ac.uk/id/eprint/1260511/)
- White, I. R., Royston, P., & Wood, A. M. 2011. Multiple imputation using chained equations: issues and guidance for practice. Statistics in medicine, 30(4), 377-399. [-PDF](https://onlinelibrary.wiley.com/doi/10.1002/sim.4067)
- Bartlett, J. W., & Morris, T. P. 2015. Multiple imputation of covariates by substantive-model compatible fully conditional specification. The Stata Journal, 15(2), 437-456. [-PDF-](https://doi.org/10.1177/1536867X1501500206)
- University College London PhD Course: Missing Data and Multiple Imputation for Cross-Sectional and Longitudinal Data

## 1. 数据缺失类型

**第一类：随机完全缺失** (MCAR/Missing Completely at Random)

当我们说**随机完全缺失**时, 我们的意思是缺失量与正在研究的观测因素无关。例如，称重秤电池耗尽、问卷在邮寄时丢失，血液样本在实验室中损坏。MCAR 是一个理想但不合理的假设。

通常来说，当数据因实验设计、设备故障或样品在运输过程中丢失或技术上不符合要求而缺失时，数据被视为 MCAR。
MCAR 数据的统计优势在于分析保持**无偏**。

下面是 MCAR 的图示，其中缺失量与变量 **X** 或 **Y** 无关，但与 **Z** 有关。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig01.png)



让我们来看看移动数据的一个示例。这里，一个样本数据有一个缺少值，不是因为变量的原因，而是因为其他原因。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig02.png)



**第二类：随机缺失** (Missing at Random/MAR)

当我们说**随机缺失**时，我们的意思是部分缺失量与分析模型中的一些其他完全观察到的变量 **X** 有关，但与 **Y** 本身的值无关。

MAR 的图示如下，其中缺失值与变量 **X** 相关，但与 **Y** 无关。它可以具有其他关系 **Z**。它与缺失的信息无关。例如，如果孩子因为生病而没有参加体检，这可能可以从其他有关孩子健康的数据中预测，但这与我们在孩子没有生病的情况下检查的内容无关。

有些人可能认为 MAR 不会导致结果有问题。然而，MAR 并不意味着可以忽略缺失的数据。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig03.png)

 

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig04.png)



**第三类：非随机缺失** (Missing not at Random/MNAR)

如果数据字符不符合 MCAR 或 MAR 的要求，则它们属于非随机丢失 (MNAR)。

当数据**缺失，但不是随机**时，缺失与缺失的内容具体相关，例如，一个人因为前一天晚上服用了药物而没有参加药物测试。一个人由于英语语言能力差，没有参加英语能力测试。

MNAR 情况的数据是有问题的。在这种情况下，获得参数无偏估计的唯一方法是对缺失的数据进行建模，但这需要对缺失变量的正确理解和领域知识。该模型可以被合并到更复杂的模型中，用于估计缺失值。

MNAR 的图示如下，其中**缺失值与变量Y**直接相关。它也可以有其他关联 (与 **X** 和 **Z**)。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig05.png)

 

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig06.png)



 

## 2. 缺失数据处理

### 2.1 尝试获取

当还处于类似调查的数据收集阶段，这种策略是完全有可能的。在这种情况下，调查者可以在受访者离开房间之前，检查一下需要的数据是否全部收集到了。有时，还可以再联系数据来源，比如再次询问缺失值的问题以获得答案。在现实场景中，这种办法很难做到。

### 2.2 合理推测

这种办法听起来很武断，并不是首选的行动方案，但有时可以根据其他结果推断出缺失的值。例如，有些调查参与者在面对矩阵相关的问题时，经常回答 2，则假设缺失值为 2。

### 2.3 舍弃数据

**按行删除** (complete-case analysis—CCA)：处理数据缺失值最常见方法是省略掉含有缺失值的样本，并分析剩余样本数据。这种方法被称为完整案例 (或可用案例) 分析或按行删除。

如果有足够大的样本，删除少量样本不是问题，并且满足 MCAR 的假设，则按行删除可能是一种合理的策略。然而，当不满足大样本或 MCAR 假设时，按行删除不是最佳策略。如果只是不满足 MCAR 假设，也会引入偏差。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig07.png)



**成对删除** (available case analysis—ACA)：在这种情况下，只忽略缺失的观察结果，并对样本存在的其他数据进行分析。如果数据在某些地方集中缺少，则只使用现有值。由于成对删除保留使用所有观察到的信息，因此它比按行删除保留更多的信息。

已知成对删除对 MCAR 或 MAR 数据造成的偏差较小。然而，如果缺失许多的观察结果，则分析仍然存在较大误差。成对删除的问题是，即使分析使用了部分有价值的数据，分析者仍然不能将分析结果进行比较，因为数据结果不够完整。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig08.png)



**删除变量**：如果某个变量指标缺少太多数据，可以选择从数据集中删除变量或列。对此没有特别的规定什么时候这样做，完全取决于情况。这应该是没办法的办法，在完全删除变量之前，需要对数据进行适当的分析，检查删除变量后模型性能是否有所改善。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig09.png)



### 2.4 保留所有数据

任何插补技术都旨在生成一个完整的数据集，然后可以用于机器学习。但是我们几乎没有办法进行插补以保留所有数据用于分析和构建模型。

**平均数原则、众数原则、半数原则**：这种插补技术的目标是用已有数据的统计估计值替换缺失数据。平均值、中值或众数可用作插补值。在均值替换中，使用一个变量的均值来代替该变量缺失的数据值。这样做的好处是不改变该变量的样本均值。均值替代的理论背景是，均值是从正态分布中随机选择的观测值的合理估计。

然而，对于非严格随机的缺失特别是在不同变量缺失值数量存在极大不平等的情况下，均值替代法可能会导致不一致的偏差。原始方差的失真和数据集中其他变量的同方差的失真是该方法的两个主要缺点。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig10.png)



当变量倾斜分布时，可以使用中值。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig11.png)



众数替换的基本原理是用最频繁出现的值替换缺失值的总体，因为这是最可能发生的情况。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig12.png)



**前次观察结果延替** (Last Observation Carried Forward/LOCF)：如果数据是时间序列数据，最广泛使用的插补方法之一是最后一次观测延替 (LOCF)。即每当缺少某个值时，将用最后一个观察到的值替换该值。这种方法是有好处的，因为它易于理解。不过，虽然这种方法很简单，它倾向于认为假设结果的值因缺少数据而保持不变，这在许多情况下似乎不太可能。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig13.png)



**下次观察结果延替** (Next Observation Carried Backward/NOCB)：和 LOCF 的方法正相反，在缺失值之后进行第一次观察，然后将结果向前推动。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig14.png)



**多重插补** (MI)：多重插补是一种处理缺失数据的统计技术。MI 的关键概念是使用观测数据的分布来估计缺失数据的一组合理值。随机分量被纳入这些估计值中，以显示其不确定性。创建多个数据集，然后进行单独但相同的分析，以获得一组参数估计值。组合估计值以获得一组参数估计值。

多重推断的好处是，恢复缺失值的自然变异性包含了缺失数据导致的不确定性，从而得出有效的统计推断。作为一种处理多个缺失变量的灵活方法，应用链式方程多重插补 (MICE) 方法。有关MI和MICE的更多信息，请参阅参考部分。以下是MICE的示意图。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/%E5%90%84%E7%A7%8D%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95_%E5%88%98%E6%A2%93%E8%8C%B5_Fig17.png)



**线性回归**：在回归插补中，使用现有变量进行预测，然后将预测值替换为实际获得的值。这种方法有几个优点，因为与列表或成对删除相比，插补保留了大量数据，并避免了显著改变标准差或分布形状。然而，与均值替代一样，当回归插补替代从其他变量预测的值时，没有添加新的信息，而样本量增加了，标准误差减少了。

**随机森林**：随机森林是一种非参数插补方法，适用于各种变量类型，在数据随机缺失和非随机缺失的情况下都能很好地工作。随机森林使用多个决策树来估计缺失值，并输出OOB (开箱即用) 插补误差估计值。一个警告是，随机森林在大数据集上效果最好，在小数据集上使用随机森林会有过度拟合的风险。

**k-NN** (k 最近邻居)：k-NN 基于最近的 k 近邻来估算缺失的属性值。基于距离度量确定邻居。一旦确定了 K 个邻居，则通过获取缺失属性的已知属性值的平均值/中值或模式来估算缺失值。

**期望最大化**：期望最大化 (EM) 是用于创建新数据集的最大似然方法。所有缺失值均采用最大似然法估算的值进行估算。这种方法从期望步骤开始，在此过程中，可能使用列表删除来估计参数 (例如，方差、协方差和均值) 。然后使用这些估计值创建回归方程，以预测缺失的数据。最大化步骤使用这些等式来填充缺失的数据。然后用新的参数重复期望步骤，确定新的回归方程以“填充”缺失的数据。重复期望和最大化步骤，直到系统稳定。



## 1. 引言

社会调查数据难免会有缺失值，常见情形之一是问卷题目跳转，比如未婚群体「婚姻幸福度」缺失，失业人群「就业满足度」缺失；一般而言，缺失值有实际值，但由于受访者拒答、隐瞒或谎报造成答案不合理、追踪调查数据后期未能成功追访等原因无法观测。比如每个受访者都有年龄的实际值，但有些人不愿意报告。

缺失值的处理也见仁见智，如果缺失情形满足 MCAR (缺失完全随机，Missing Completely at Random) 则可直接删除缺失值获得无偏估计，也可适当采取单一补漏、多重补漏等处理方式，但没有统一标准。

本文主要和大家介绍数据缺失值直接替换为 0 的处理方式。

 

## 2. When no news is zero news, 可替换

只有当你有足够理由说明缺失数据的实际值为 0 时，才能将缺失值替换为 0，否则不可。 (参考 Statalist 问题[「When should missing data, in numerical variables, be replaced by zeros?」](https://www.statalist.org/forums/forum/general-stata-discussion/general/1341703-when-should-missing-data-in-numerical-variables-be-replaced-by-zeros)中 [Clyde Schechter](https://www.statalist.org/forums/member/182-clyde-schechter) 的回答)

在 [PMean: Can I replace missing values with zero?](http://blog.pmean.com/missing-equals-zero/) 这篇博客中，作者也提出，「有时，缺失值就表示没有，比如调查工资、利息、股息和特许权使用费四种收入构成时，受访者没有回答股息收入是因为没有这种收入」，这种情况下，将缺失值替换为 0 就比较合理。

Allison (2010) 中介绍了 **虚拟变量调整 (Dummy variable adjustment)** 这种方法，书中举例如下。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Allison2010pp638-639.png)



某变量缺失处理步骤如下：

- 首先，生成一个虚拟变量表示如果缺失则取值为 1；
- 其次，将变量缺失值替换为某个补漏值 (imputes)，通常为 0；
- 最后，将该变量和虚拟变量同时加入回归。

该方法可以用于所有解释变量。该方法的好处在于没有删除缺失值，将所有可获信息包含在回归模型中。但可能会造成估计偏误，如果无偏估计不是必需的，可采用这一方法。

> **参考资料**：Allison, Paul D. Missing data. Thousand Oaks, CA: Sage, 2010. [-PDF-](https://statisticalhorizons.com/wp-content/uploads/Allison_MissingData_Handbook.pdf),pp. 638-639

由此可见，将缺失值替换为 0 是虚拟变量调整法的特殊情形之一。

 

## 3. 缺失值替换为 0 的案例

在公司财务研究中，我们经常需要把「研发支出 (R&D)」作为一个解释变量放入模型，然而，该变量往往存在严重的缺失值。棘手之处在于，我们难以判断这些缺失值到底是因为公司的研发支出为零 (这种情况下将缺失值替换为零是没有问题的)，还是它们出于商业机密考虑没有披露研发支出数据 (这种情况下的研发支出反而可能很高)。

多篇大牛的文章都是采用上述方法进行处理的，这种方法的始作俑者应该是「样本选择偏误」的大佬 Hausman 教授 (Hausman et al., 1984, pp. 912)。

如下是连老师的一篇工作论文「连玉君, 黄曼琪, 王俊. 中国上市公司关注目标市场资本结构吗? 2021, 工作论文」中一个脚注中的表述：

> 「本文将未披露研发费用的上市公司的研发费用一项取值为 0。为了控制由此可能导致的样本选择偏差，参考 Fama and French (2002, pp. 21) 和 Flannery and Rangan (2006, pp. 477) 等人的做法，为了区分研发费用真实值为 0 与研发费用缺漏的观察值，加入是否披露研发费用的虚拟变量作为控制变量。这一做法最早源于)。」

下面，我们对上述脚注中提及的几篇文章的处理方法做个简单的介绍：

### 3.1 Flannery and Rangan (2006, JFE)

Flannery and Rangan (2006) 就采用了将 R&D 支出缺失值替换为 0 的虚拟变量调整法。首先，生成 R&D_DUM 哑变量，当 R&D 支出缺失则取值为 1，否则取值为 0；其次，将 R&D 支出缺失值替换为 0；最后，将 R&D 支出和 R&D_DUM 哑变量同时加入回归。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Flannery2006pp477.png)

 

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20210602000727.png)



> **参考资料**：Flannery, M. J. and Rangan, K. P. Partial Adjustment toward Target Capital Structures[J], Journal of Financial Economics, 2006, 79(3): 469-506. [-PDF-](http://sci-hub.ren/10.1016/J.JFINECO.2005.03.004), pp. 477

 

### 3.2 Fama and French (2002, RFS)

Fama and French (2002) 的模型中也加入了表示 R&D 支出为缺失值的哑变量。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/Fama2002pp11.png)



> **参考资料**：Fama, E. F. and French, K. R. Testing Trade-Off and Pecking Order Predictions About Dividends and Debt[J], The Review of Financial Studies, 2002, 15(1): 1-33. [-PDF-](http://sci-hub.ren/10.1093/RFS/15.1.1), pp. 21

 

### 3.3 Hausman et al. (1978, Econometrica)

上述例子，我们无法明晰 R&D 支出缺失则替换为 0 的合理性，但在 Hausman et al. (1984) 中很明显。其中，���*n**i**t* 是表示企业专利数的非负整数。如果 ���*n**i**t* 取值为 0，则新生成的变量 ���(���)*l**o**g*(*n**i**t*) 缺失，生成一个哑变量当 ���(���)*l**o**g*(*n**i**t*) 缺失或 ���=0*n**i**t*=0 取值为 1，再将 ���(���)*l**o**g*(*n**i**t*) 因 ���=0*n**i**t*=0 而缺失的值替换为 0，将哑变量加入回归。

![img](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20210601224953.png)



> **参考资料**：Hausman, Jerry A, Bronwyn H Hall, and Zvi Griliches. 1984. Econometric Models for Count Data with an Application to the Patents-R&D Relationship. Econometrica 52 (4): 909–938. [-PDF-](https://www.jianguoyun.com/p/DVvK0jgQtKiFCBjEwvcD), pp. 912

 

## 4. Stata 命令：How 批量替换为 0

Stata 中有多种方法可以把缺失值替换为 0。最基本的方法就是使用 `replace` 命令：

```stata
replace x=0 if x>=. | missing(x)
```

或采用 `mvencode` 命令进行批量处理：

```stata
mvencode x1 x2 x3, mv(0)
```

也可以采用循环语句：

```stata
global X "x1 x2 x3"
  foreach var of varlist $X {
    replace `var' = 0 if `var'>=.
  }
```

 

## 5. 总结

总体而言，**虚拟变量调整**(Dummy variable adjustment)，或将缺失值替换为 0 适用情形很有限，直接使用会造成估计偏误问题。

最后，以 Allison (2010) 概要作结：一般而言，删除缺失值是最好的方法，因为如果缺失完全随机 (MCAR) 则估计无偏，如果缺失变量作为解释变量做回归，则即使缺失不随机也能实现无偏估计。但为了尽可能不减少样本量，建议采用多重补漏，尤其是极大似然法。

 

## 6. 参考文献

- Allison, Paul D. Missing data. Thousand Oaks, CA: Sage, 2010. [-PDF-](https://statisticalhorizons.com/wp-content/uploads/Allison_MissingData_Handbook.pdf) ,pp. 638-639
- Hausman, Jerry A, Bronwyn H Hall, and Zvi Griliches. 1984. Econometric Models for Count Data with an Application to the Patents-R&D Relationship. Econometrica 52 (4): 909–38. [-PDF1-](https://www.jianguoyun.com/p/DVvK0jgQtKiFCBjEwvcD), pp. 912; [-PDF2-](http://sci-hub.ren/10.3386/T0017), pp. 7
- Flannery, M. J. and Rangan, K. P. Partial Adjustment toward Target Capital Structures[J], Journal of Financial Economics, 2006, 79(3): 469-506. [-PDF-](http://sci-hub.ren/10.1016/J.JFINECO.2005.03.004), pp.477
- Fama, E. F. and French, K. R. Testing Trade-Off and Pecking Order Predictions About Dividends and Debt[J], The Review of Financial Studies, 2002, 15(1): 1-33. [-PDF-](http://sci-hub.ren/10.1093/RFS/15.1.1), pp. 21





## 1. 引言

在实证研究中，我们经常会遇到数据缺失的问题。在样本较大的情况下，我们可以删除缺失值，而在样本较小的情况下，缺失值的影响会变得很大，此时，填补数据这项工作就变得相对重要。

本文主要介绍了 Stata 中较为常用的缺失数据处理命令 `tsfill` 和 `ipolate`，旨在为大家处理缺失数据问题时提供帮助。

## 2. 问题与方法

### 2.1 缺失数据会带来的问题

通常，在缺失部分数据的情况下，只要数据量足够大，我们可以将含有缺失值的样本删掉，并且不会对结果产生太大影响。但是，在「样本量小」和「缺失数据多」的情况下，我们简单的删掉数据，会损失较多的信息，并且使得结果有偏。

例如，下表中有 8 个样本，左边为含有缺失值的数据，右边为完整数据，并且左边部分 ���*a**g**e* 有 4 个缺失值。当我们删除缺失值时，左边 ���*a**g**e* 均值为 39，而右边 ���*a**g**e* 均值为 29.75，可以看出二者还是有很大差别的。

```stata
+--------------------------------------+
|   含有缺失值的数据  |     完整数据     |
+--------------------------------------+
|Case  Age  Gender   | Case Age Gender |
+--------------------------------------+
|1    .     Female   |   1  21  Female |
|2    .     Male     |   2  22  Male   |
|3    39    Male     |   3  39  Male   |
|4    .     Female   |   4  20  Female |
|5    42    Male     |   5  42  Male   |
|6    .     Female   |   6  18  Female |
|7    37    Male     |   7  37  Male   |
|8    38    Male     |   8  39  Male   |
+--------------------------------------+
 (缺失数据和完整数据的基本格式)
```

### 2.2 缺失数据的常用方法

求均值

- 好处：简单
- 坏处：取均值会降低数据的方差
- 使用范围：当分组数据特征是可以观测到的情况下，可以分组求均值

删除缺失值

- 好处：比较干净的剔除了不完整的缺失数据
- 坏处：减少了样本数量，尤其是数据量不大的时候
- 使用范围：如果缺失数据量小于 2%

插补法

- 好处：简单
- 适用范围：当数据的缺失不是随机出现的时候。时间序列数据例如 GDP，收入等比较适用

## 3. tsfill 和 ipolate 命令简介

在时间序列数据中，`ipolate` 需要与 `tsfill` 搭配使用。首先用`tsfill` 补充缺失时间，然后用 `ipolate` 进行「插值或外推」补齐数据。

`tsfill` 注意事项

- `tsfill` 使用前必须将数据设定为「时间序列数据」或「面板数据」；
- `tsfill` 的主要作用是对数据中时间变量 (�������*t**im**e**v**a**r*) 的缺失值进行填补或扩充。

`ipolate` 原理

- 如一份数据有 3 个变量 �*t*，�*y* 和 �*x*， �*t* 是时间，且 �*y* 变量在 �1*t*1 时点有缺失值 �1*y*1；

```stata
+-------------+
| t    y    x |
|-------------|
| 0   65    8 |
| 1    .   15 |
| 2   80   20 |
+-------------+
```

- �1*y*1 的计算公式：

�1=�2−�0�2−�0(�1−�0)+�0*y*1=*x*2−*x*0*y*2−*y*0(*x*1−*x*0)+*y*0

�1=80−6520−8(15−8)+65=73.75*y*1=20−880−65(15−8)+65=73.75

## 4. Stata 实操：tsfill 和 ipolate 命令

下面对 `tsfill` 和 `ipolate` 在时间序列和面板数据中的使用方法进行举例说明。

### 4.1 时间序列数据

以 `tsfillxmpl` 这份数据为例，数据中缺失了 1995 年 9 月、1995 年 10 月、1996 年 2 月的数据。

```stata
. use https://www.stata-press.com/data/r16/tsfillxmpl, clear
. tsset
time variable:  mdate, 1995m7 to 1996m3, but with gaps
                delta:  1 month
. list mdate income, sep(0)
     +------------------+
     |   mdate   income |
     |------------------|
  1. |  1995m7     1153 |
  2. |  1995m8     1181 |
  3. | 1995m11     1236 |
  4. | 1995m12     1297 |
  5. |  1996m1     1265 |
  6. |  1996m3     1282 |
     +------------------+
```

`tsfill` 的作用在于「撑大样本 (新增观察值)」，以便让缺失值所在空位一目了然。

```stata
. tsfill
. list mdate income, sep(0)
     +------------------+
     |   mdate   income |
     |------------------|
  1. |  1995m7     1153 |
  2. |  1995m8     1181 |
  3. |  1995m9        . |
  4. | 1995m10        . |
  5. | 1995m11     1236 |
  6. | 1995m12     1297 |
  7. |  1996m1     1265 |
  8. |  1996m2        . |
  9. |  1996m3     1282 |
     +------------------+
```

在得到了这几个新增的观测值后，我们就可以使用 `ipolate` 创建新变量，并进行数据填充。

```stata
. ipolate income mdate, gen(ipinc) //income 是 mdate 函数
. list mdate income ipinc, sep(0)
     +------------------------------+
     |   mdate   income       ipinc |
     |------------------------------|
  1. |  1995m7     1153        1153 |
  2. |  1995m8     1181        1181 |
  3. |  1995m9        .   1199.3333 |
  4. | 1995m10        .   1217.6667 |
  5. | 1995m11     1236        1236 |
  6. | 1995m12     1297        1297 |
  7. |  1996m1     1265        1265 |
  8. |  1996m2        .      1273.5 |
  9. |  1996m3     1282        1282 |
     +------------------------------+
```

实际上，`ipolate` 只能填补数值范围内的缺漏值，无法填补数值范围外的缺漏值，即只能用于「插值」。若要进行「外推」，我们还需要在 `ipolate` 命令后加上 `epolate` 选项。关于「插值」和「外推」区别，详见[「The Difference Between Extrapolation and Interpolation」](https://www.thoughtco.com/extrapolation-and-interpolation-difference-3126301)。

具体来看，我们先生成一份数据，然后剔除一部分数据，最后再分别用「插值」和「插值+外推」的方法生成变量 �1*y*1 和 �2*y*2。观察下表，我们可以发现，在 `list x if ymissing != .` 范围内，�1*y*1 和 �2*y*2 是相同的，但是在范围外，「插值法」不起作用，而「插值+外推法」可以填充缺失值。

```stata
*-产生一份数据
  clear all
  set obs 20
  set seed 10101
  gen id =_n
  gen year = _n+1999
  gen x = rnormal(8,1)
  gen e = rnormal(2,1)
  gen y=1+2*x+e
  tsset year

*-将 y > 20 定义为缺失值
  gen ymissing = y 
  replace ymissing = . if ymissing > 20

*-进行插值和外推
  ipolate ymissing x, gen(y1) 
  ipolate ymissing x, gen(y2) epolate 

*-列示数据
  sort x
  list year y x ymissing y1 y2, sep(0)
+---------------------------------------------------------------+
     | year          y          x   ymissing          y1          y2 |
     |---------------------------------------------------------------|
  1. | 2016   14.22344   6.224262   14.22344   14.223439   14.223439 |
  2. | 2003   16.01714   6.299623   16.01714   16.017143   16.017143 |
  3. | 2012    15.6483   6.631131    15.6483   15.648301   15.648301 |
  4. | 2018   15.23791   6.776969   15.23791   15.237909   15.237909 |
  5. | 2017   19.02291   7.256191   19.02291   19.022915   19.022915 |
  6. | 2014   18.78441   7.443309   18.78441    18.78441    18.78441 |
  7. | 2004   17.76631    7.66682   17.76631    17.76631    17.76631 |
  8. | 2019   19.20397   7.694068   19.20397   19.203974   19.203974 |
  9. | 2009   19.79814   7.845325   19.79814   19.798141   19.798141 |
 10. | 2011   18.87022   8.242313   18.87022   18.870222   18.870222 |
 11. | 2002   20.07537   8.258301          .   19.029664   19.029664 |
 12. | 2008   19.78762   8.334302   19.78762   19.787622   19.787622 |
 13. | 2010   19.64958   8.389261   19.64958   19.649576   19.649576 |
 14. | 2000   20.51375   8.392216          .   19.649501   19.649501 |
 15. | 2013   20.21895   8.769518          .   19.639873   19.639873 |
 16. | 2001   19.63783   8.849615   19.63783   19.637829   19.637829 |
 17. | 2005   18.35985   9.265242   18.35985   18.359848   18.359848 |
 18. | 2007   22.23178   9.515868          .           .   17.589214 |
 19. | 2015    25.5771   10.40832          .           .   14.845067 |
 20. | 2006    24.7197   10.81053          .           .   13.608347 |
     +---------------------------------------------------------------+
```

### 4.2 面板数据

以 **tsfillxmpl2.dta** 为例，我们可以看到个体 2 缺失了 1991 年数据。

```stata
. webuse tsfillxmpl2, clear
. tsset
       panel variable:  edlevel (unbalanced)
        time variable:  year, 1988 to 1992, but with a gap
                delta:  1 unit   
. list edlevel year income, sep(0)
     +-------------------------+
     | edlevel   year   income |
     |-------------------------|
  1. |       1   1988    14500 |
  2. |       1   1989    14750 |
  3. |       1   1990    14950 |
  4. |       1   1991    15100 |
  5. |       2   1989    22100 |
  6. |       2   1990    22200 |
  7. |       2   1992    22800 |
     +-------------------------+
```

与时间序列数据类似，我们可以通过 `tsfill` 命令将缺失数据扩充进来。

```stata
. tsfill
. list edlevel year income, sep(0)
     +-------------------------+
     | edlevel   year   income |
     |-------------------------|
  1. |       1   1988    14500 |
  2. |       1   1989    14750 |
  3. |       1   1990    14950 |
  4. |       1   1991    15100 |
  5. |       2   1989    22100 |
  6. |       2   1990    22200 |
  7. |       2   1991        . |
  8. |       2   1992    22800 |
     +-------------------------+
```

当然，我们也可以按照「平衡面板」数据结构来进行观察值填补，只需在 `tsfill` 命令后加入 `full` 选项。

```stata
. webuse tsfillxmpl2, clear
. xtset edlevel year
       panel variable:  edlevel (unbalanced)
        time variable:  year, 1988 to 1992, but with a gap
                delta:  1 unit
. tsfill, full
. list edlevel year income
     +-------------------------+
     | edlevel   year   income |
     |-------------------------|
  1. |       1   1988    14500 |
  2. |       1   1989    14750 |
  3. |       1   1990    14950 |
  4. |       1   1991    15100 |
  5. |       1   1992        . |
     |-------------------------|
  6. |       2   1988        . |
  7. |       2   1989    22100 |
  8. |       2   1990    22200 |
  9. |       2   1991        . |
 10. |       2   1992    22800 |
     +-------------------------+
```

可以看到在扩充了 3 个观察值后，数据变成了「平衡面板」数据。接下来，我们要对缺失值填充。

```stata
. ipolate income year, gen(ipinc1) 
. list edlevel year income ipinc1
     +----------------------------------+
     | edlevel   year   income   ipinc1 |
     |----------------------------------|
  1. |       1   1988    14500    14500 |
  2. |       1   1989    14750    18425 |
  3. |       1   1990    14950    18575 |
  4. |       1   1991    15100    15100 |
  5. |       1   1992        .    22800 |
     |----------------------------------|
  6. |       2   1988        .    14500 |
  7. |       2   1989    22100    18425 |
  8. |       2   1990    22200    18575 |
  9. |       2   1991        .    15100 |
 10. |       2   1992    22800    22800 |
     +----------------------------------+
```

## 5. iploate 方法评价

**优点**

- 定义简单
- 当数据之间没有任何相关特征的时候比较适用

**缺点**

- 它仅考虑了数据的局部结构；
- 它通常会减少数据的变异性；
- 显然补齐的数据并不是数据的完整特征，数据被人为的简单化了。

**注意**

- 通过人为地在数据中引入间隙，可以了解「插值法」处理该数据的效果；
- 尝试不同的插值方法来了解它们之间的一致程度。

## 参考资料

- Hamming R. Numerical methods for scientists and engineers[M]. Courier Corporation, 2012. [Link](https://books.google.com.hk/books?hl=zh-CN&lr=&id=Z2owE_0LQukC&oi=fnd&pg=PP1&dq=Numerical+methods+for+scientists+and+engineers&ots=2zbFUCXPs0&sig=TlbwyTC007fdlk2d3y_EQd5rt8w&redir_esc=y#v=onepage&q=Numerical methods for scientists and engineers&f=false)
- Morton, B.R. Numerical approximation[M]. London: Routledge and Kegan Paul, 1964. [Link](https://olin.tind.io/record/132418/)
- Press W H, Teukolsky S A, Vetterling W T, et al. Numerical recipes 3rd edition: The art of scientific computing[M]. Cambridge university press, 2007. [Link](https://books.google.com.hk/books?hl=zh-CN&lr=&id=1aAOdzK3FegC&oi=fnd&pg=PA1&dq=the+art+of+scientific+computing&ots=3kVjIfHmif&sig=AZVeJic8519970MskST65kr4En0&redir_esc=y#v=onepage&q=the art of scientific computing&f=false)
- The Difference Between Extrapolation and Interpolation [Link](https://www.thoughtco.com/extrapolation-and-interpolation-difference-3126301)



## 1. 何谓离群值？

 

> **离群值 (outliers)**
> 是指在一份数据中,与其他观察值具有`明显不同特征`的那些观察值。

 

然而，并没有一个明确的准则来判断哪些观察值属于“离群值”。这主要取决于多种因素。

**比如，下图中：** 姚明算不算离群值？郭敬明呢？

![Paste_Image.png](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/7692714-5e36ee896b095c01.png)



对于**姚明算不算离群值？**，这本身就是一个非常不严谨的问题。

因为，我们可以找到很多变量来描述**姚明**的特征，比如身高、颜值、智商、情商、跑步速度、沟通能力，等等。

可能所有看到图片的读者的第一反应都是，**姚明好高！\**如果据此推断\**“姚明的身高是离群值”**，那你实际上潜意识里把图片中四人的身高构成的样本视为从一个更大的母体中的随机抽样。换言之，你将**普通人的身高**作为分析对象。此时，基本上可以认为姚明是离群值。

以我自己的经历而言，我从 16 岁停止长身高开始，到现在过去了 20 多年，**亲眼**见过的人应该不少于 10000 人了。其中只有 3-5 位身高超过 2 米，最高的那位身高 2.10 米，曾是广东排球队的队员。根据 NBA 的[官方统计](http://www.nba.com/features/survey2002_height.html)，姚明的身高是 2.26 米。这意味着，若以普通人的身高作为母体来随机抽样，抽取的 10000 个观察值中身高超过 2.26 米的概率是接近于 0 ( 0/10000 = 0)。

若将**对照组**调整为 NBA 球员，情况又如何呢？在 [NBA 的官网](http://www.nba.com/features/survey2002_height.html)上可以看到，2002-2003 赛季所有 413 个球员中，姚明身高位列第二。

然而，若我们将**对照组**改为“NBA 中锋” ，从下图可以看到， NBA 中锋的平均身高为 2.11 米。由于不知道标准差，所以无法判断具体的分布，但可以想象，姚明站在一群 NBA 中锋中，虽然仍是高个儿，但若说他的身高是离群值，怕是有不少中锋会不高兴。

![image.png](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/7692714-53ec8a451d8441ff.png)



如果抛开身高，从其他特征来看，比如沟通能力，智商等，姚明可能都不能算做离群值，应该都在平均值附近。

> 因此，离群值其实是一个**主观概念**！若是一般人为参照对象，
> 对于**刘翔**，其奔跑速度可能是离群值，但身高则未必是；
> 对于郭敬明，其身高和创作能力可能都是离群值，但情商和智商则未必是；

此外，从姚明的例子可以看出，在处理数据时，我们可以把姚明的身高视为离群值，从样本中删除之——所谓的`截尾`；也可以将**姚明**的资料视为**姚明明**，后者的身高被我们人为设定为 1.98 米 (样本中的第 1 百分位数)，而其他方面的资料则与**姚明**完全相同——所谓的`缩尾`。

 

## 2. 离群值存在会怎样？

大多数的参数统计数值，如 **均值、标准差、相关系数** 等，以及基于这些参数的统计分析，均对离群值高度敏感。因此，离群值的存在会对数据分析造成极大影响。

> 范例：美国妇女工资的决定因素

先看一看数据中小时工资( wage )的分布情况

```stata
sysuse nlsw88.dta, clear
histogram wage,  ylabel(, angle(0))
```

绘图结果如下：

![妇女小时工资的直方图](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/8578251-3a2cbba9442dd5dc.png)



从上图中可以发现，小时工资在 20 以上的观察值比重较小（在 1988 年，仅有极少的女性能够在每小时赚到 20 美元以上！这些是所谓的 **高薪个体**。），这些观察值很可能属于离群值。

下面我们来看一下，在包含和不包含 **高薪个体** 的情况下，工资方程的回归结果分别是怎样的。

```stata
. sysuse nlsw88.dta, clear
. qui reg wage age  ttl_exp  collgrad
. est store With
. qui reg wage age  ttl_exp  collgrad if wage < 20
. est store No

. local m "With No"
. esttab `m', mtitle(`m') compress replace ///
         b(%6.3f) s(N r2_a) drop(`drop')   ///
         star(* 0.1 ** 0.05 *** 0.01)      ///
	     addnotes("*** 1% ** 5% * 10%") nogap


------------------------------------
                 (1)          (2)
                With           No
------------------------------------
age           -0.123***    -0.042**
             (-3.28)      (-2.00)
ttl_exp        0.309***     0.281***
             (12.39)      (20.03)
collgrad       3.241***     2.764***
             (12.09)      (18.06)
_cons          7.927***     4.462***
              (5.43)       (5.40)
------------------------------------
N           2246.000     2174.000
r2_a           0.131        0.273
------------------------------------
t statistics in parentheses
*** 1% ** 5% * 10%
* p<0.1, ** p<0.05, *** p<0.01
```

从以上回归结果中可以发现，在去掉样本中的 **高薪个体** 后，模型的 **拟合优度** (`r2_a`) 明显提高，年龄（`age`）系数的显著性有所下降，这些均体现了离群值对分析所带来的影响。

 

## 3. 离群值的处理方法

- 对数转换
- 缩尾
- 截尾
- 插值

### 3.1 对数转换

> 对存在离群值的变量作对数转换可以克服其离群值问题，且对数转换并不影响各观察值之间在此变量上的相对大小。

为什么对数转换可以克服离群值问题呢？这是因为，转换后数据的分布会变得**更加集中**。换句话说，虽然对数转换并不改变原有数值的相对大小关系，但却使得转换后数值之间的**相对距离缩小了**。

比如，在下表中， 10 与 1000 相差百倍，但二者的对数值却仅相差 3 倍。可见对数转换后，其分布变得更加集中了。

| x    |    ln( x )    |
| ---- | :-----------: |
| 10   |      2.3      |
| 100  | 2.3 × 2 = 4.6 |
| 1000 | 2.3 × 3 = 6.9 |

沿前例：
对 wage 变量进行对数转换

```stata
sysuse nlsw88.dta, clear
gen ln_wage = ln(wage)
```

看看对数转换后发生了什么变化

```stata
histogram wage,  ylabel(, angle(0)) xtitle("wage") name(fig1, replace)
histogram ln_wage, ylabel(, angle(0)) xtitle("ln_wage") name(fig2, replace)
graph combine fig1 fig2
```

绘图结果如下

![对数转换.png](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/8578251-4e97e71ede232cff.png)



从上图中可见，经对数转换后的工资变量（`ln_wage`）的离群值明显减少，分布也更加集中。

> 需要注意的是，如果用对数转换后的数据进行回归分析，则回归模型中`系数的经济含义会发生变化`。

以线性回归为例，下表列示了不同模型设定下，回归系数的经济含义。

| 回归模型                                         | 回归系数( β )的经济含义 |
| ------------------------------------------------ | :---------------------- |
| �=�+��+�*y*=*α*+*β**x*+*u*                       | 边际效应                |
| ��(�)=�+���(�)+�*l**n*(*y*)=*α*+*βl**n*(*x*)+*u* | 弹性                    |
| ��(�)=�+��+�*l**n*(*y*)=*α*+*β**x*+*u*           | 半弹性                  |

 

### 3.2 缩尾

处理思路：将超出变量特定百分位范围的数值**替换为**其特定百分位数值的方法。我们可以用 `winsor` 或 `winsor2` 命令实现这一处理。

沿前例，对 **wage** 变量进行缩尾处理：

```stata
sysuse nlsw88.dta, clear
winsor wage, gen(wage_w) p(0.025)
```

- `gen(wage_w)` 选项：为缩尾后所得的新变量设定名称为 **wage_w**。
- `p(0.025)` 选项：指定分别在第 2.5 百分位和第 97.5 百分位进行缩尾。即，将 wage 变量中小于其 2.5 百分位的数值 **替换为** 其 2.5 百分位数值；将 wage 变量中大于其 97.5 百分位的数值 **替换为** 其 97.5 百分位数值。（**注**：这一过程是 **双侧缩尾**，是 `winsor`命令的默认处理方式。）

看看缩尾后发生了什么变化

```stata
histogram wage,  ylabel(, angle(0)) xtitle("wage") name(fig1, replace)
histogram wage_w,  ylabel(, angle(0)) xtitle("wage_w") name(fig2, replace)
graph combine fig1 fig2
```

绘图结果如下

![winsor.png](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/8578251-6cca14ace928b9c0.png)



缩尾后，对应于之前变量的 `2.5` 和 `97.5` 百分位上的数值变多了，这是由原来超过该范围的“离群值”转换而来的。

但是，我们之前已经发现， wage 变量的原始数据似乎只在右侧存在离群值，在左侧并不存在离群值。我们可以通过 `winsor` 命令的 `highonly` 或 `lowonly` 选项来进行 **单侧缩尾** 处理。

仅对 **wage** 变量进行 **右侧** 缩尾

```stata
sysuse nlsw88.dta, clear
winsor wage, gen(wage_wh) p(0.025) highonly
histogram wage_wh,  ylabel(, angle(0)) xtitle("wage_wh")
```

绘图结果如下

![winsor_h.png](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/8578251-da895f112b263a06.png)



### 3.3 截尾

将超出变量特定百分位范围的数值予以 **删除** 的方法。

```
help winsor2
```

沿前例：
对 wage 变量进行截尾处理

```stata
sysuse nlsw88.dta, clear
winsor2 wage, cut(2.5 97.5) trim
```

- `cut(2.5 97.5)` 选项：指定分别在第 2.5 百分位和第 97.5 百分位进行截尾。即，将 **wage** 变量中小于其 2.5 百分位的数值或大于其 97.5 百分位的数值予以 **删除**。
- `trim` 选项：指定进行 **截尾** 处理（否则，默认进行缩尾处理）。

看看截尾后发生了什么变化

```stata
histogram wage,  ylabel(, angle(0)) xtitle("wage") name(fig1, replace)
histogram wage_tr,  ylabel(, angle(0)) xtitle("wage_tr") name(fig2, replace)
graph combine fig1 fig2
```

绘图结果如下

![trim.png](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/8578251-d675fbbd54abbfde.png)



超过原来数据 2.5% ~ 97.5% 范围的部分被 **截断** 了。

同样，我们可能仅需对 **wage** 变量进行右侧截尾

```stata
sysuse nlsw88.dta, clear
winsor2 wage, cut(0 97.5) trim  suffix(_trh)
histogram wage_trh,  ylabel(, angle(0)) xtitle("wage_trh")
```

绘图结果如下

![trim_h.png](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/8578251-316baba27674a324.png)



------

> **延伸** ：`winsor2`命令 —— **一个命令满足缩、截尾全部需要**

> `winsor2`命令比`winsor`命令的功能丰富得多。不只是因为`winsor2`可以执行缩尾和截尾两种操作，更重要的是，它还增加了**多变量操作**、**分组操作**、**替换原变量**等实用功能。

`winsor2` 命令的语法如下

```
winsor2 varlist [if] [in], [ suffix(string) replace trim cuts(# #) by(groupvar) label ]
```

- `varlist`：可以输入**多个变量**进行操作。
- `replace`选项：指定用处理后的变量**替换原变量**。
- `trim`选项：指定进行**截尾**处理（否则`默认`进行缩尾处理）。
- `cuts(# #)`选项：指定进行缩、截尾处理的**百分位**。`默认`为**cuts(1 99)**，即在 1% 、 99% 分位数上进行缩、截尾。同理， cuts(`0` #) 表示**右侧**缩、截尾。 cuts(# `100`) 表示**左侧**缩、截尾。
- `by(groupvar)`选项：指定**分组操作**的组别变量。

### 3.4 插值

应用原有数据信息对离群值赋予一个相对合理的**新值**的方法。

对数据进行赋值的方法有很多。比如，随机赋值、最近点赋值、均值赋值、回归赋值等。插值法是对数据赋值的一种方法，一般指的是线性插值（ linear interpolation ）。参见 [维基百科 - 插值](https://baike.hk.xileso.top/wiki/插值)。

在 Stata 中，`ipolate` 命令可以进行线性插值操作。`impute` 命令可以进行回归赋值操作。

- [Stata：缺失值的填充和补漏](https://www.lianxh.cn/news/4404052e7b336.html)
- [Stata 数据处理：面板数据的填充和补漏](https://www.lianxh.cn/news/c2febe0f3530a.html)

 

## 4. 小结

最后，具体采用哪种方法来处理离群值需要结合各方法的特点和研究的需要而定。

比如，在上述方法中，对数转换对某变量的**全部观察值**均进行了处理，而其他方法则仅对变量中的离群值进行了处理；插值法利用了原有数据中的**相关性信息**，其他方法则没有利用这些信息；截尾处理会**减少数据中的样本量**，其他方法则保留了原有数据的样本量。在实际操作中应该结合这些特点进行选择。

此外，对于不同的研究领域，也有不同的适用方法和偏好。比如，在公司金融领域，缩尾被较为广泛地运用。而在时间序列分析中，则更适宜采用插值法。