# 07.文件IO操作

## 一、文件操作

实际开发中常常会遇到对数据进行持久化的场景，所谓持久化是指将数据从无法长久保存数据的存储介质（通常是内存）转移到可以长久保存数据的存储介质（通常是硬盘）中。实现数据持久化最直接简单的方式就是通过**文件系统**将数据保存到**文件**中。计算机的**文件系统**是一种存储和组织计算机数据的方法，它使得对数据的访问和查找变得容易，文件系统使用**文件**和**树形目录**的抽象逻辑概念代替了硬盘、光盘、闪存等物理设备的数据块概念，用户使用文件系统来保存数据时，不必关心数据实际保存在硬盘的哪个数据块上，只需要记住这个文件的路径和文件名。

### 1.文件的类型

文件是存储在辅助存储器上的一组数据序列，可以包含任何数据内容。文件是数据的集合和抽象，文件包括文本文件和二进制文件两种类型。文本文件一般由单一特定编码（如UTF-8编码）的字符组成的易于统一展示和阅读的长字符串，大部分文本文件都可以通过文本编辑软件或文字处理软件创建、修改和阅读。二进制文件直接由比特0和比特1组成，没有统一的字符编码但有特定格式形成的文件，文件内部数据的组织格式与文件用途有关，如png格式的图片文件、avi格式的视频文件。**二进制文件和文本文件最主要的区别在于是否有统一的字符编码。**

二进制文件由于没有统一的字符编码，只能当作字节流，而不能看作是字符串。无论文件创建为文本文件或者二进制文件，都可以用“文本文件方式”和“二进制文件方式打开，但打开后的操作不同。

> **文件名** 由 **主名** 和 **扩展名** 两部分组成，主名和扩展名用英文句号`.`隔开，即`主名.扩展名`。扩展名用于表示文件的类型，文件主名为用户自定义的文件名称`test.txt/爱情买卖.mp3`。

#### 2.文件的路径

**文件路径** 是用于描述文件系统资源的一个文本标识。文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。文件存放在外部存储器中的某些位置上，经由文件系统管理后，被系统以文件路径标识，系统可以通过文件路径检索到对应文件。标准的 DOS 路径可由以下三部分组成：

- **卷号**或**驱动器号**，后跟卷分隔符 `:`
- **目录名**。 目录分隔符 (`/`或`\`) 用来分隔嵌套目录层次结构中的子目录。
- **可选的文件名**。 目录分隔符(`/`或`\`) 用来分隔文件路径和文件名。

| 路径分类 |                                                              |
| -------- | ------------------------------------------------------------ |
| 绝对路径 | 包含驱动器号（或卷号）和 全部目录名的路径，如果绝对路径中包含文件名，则称其为文件的绝对路径。 |
| 相对路径 | 未指定卷号或驱动器号， 或者目录名不以分隔符开头的路径。      |

> 绝对路径对应着一个明确、唯一且固定的文件或目录，也称为 完整路径 或 全路径；l相对路径无法直接确定一个唯一的且固定的文件或目录，随着**当前目录**或**当前驱动器**变化。

#### 3.文件的打开与关闭

Python对文本文件和二进制文件具有统一的操作步骤，即“打开一操作一关闭”。操作系统中的文件默认处于存储状态，首先需要将其打开，使得当前程序有权操作这个文件，打开不存在的文件系统可以创建这个文件。打开后的文件处于占用状态，此时，另一个进程不能操作这个文件。可以通过一组方法读取文件的内容或向文件写人内容，操作之后需要将文件关闭，关闭将释放对文件的控制使文件恢复成存储状态，此时，另一个进程将能够操作这个文件。

|               函数                |                说明                |
| :-------------------------------: | :--------------------------------: |
| `open(name[, mode[, buffering]])` | 打开一个文件并返回一个`file`对象。 |
|             `close()`             |      关闭一个文件`file`对象。      |

`close()`函数用于关闭一个文件对象，这里不再赘述，但需要注意，打开的文件对象必须手动关闭，否则占用内存且占用文件的使用授权。

```python
open(file, mode='rt', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
# name 一个包含了文件路径的字符串
# mode 文件打开处理模式，相当于授予文件对象对文件处理的权限
# encoding 当打开的是文本文件时，可以通过encoding指定编码格式
# buffering 设置缓冲，如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。
# errors 报错级别
# newline 区分换行符
# closefd 传入的file参数类型
# opener 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。
```

**处理模式mode**

| 打开模式 | 说明                                                         |
| :------: | ------------------------------------------------------------ |
|   `b`    | 二进制文件模式，也可以与                                     |
|   `t`    | 文本文件模式，默认值。                                       |
|   `r`    | 只读模式，文件的指针将会放在文件的开头，如果文件不存在返回异常`FileNotFoundError`，默认值。 |
|   `w`    | 覆写模式，文件指针将会放在文件的开头，文件不存在则创建，存在则完全覆盖原文件。 |
|   `x`    | 创写模式，文件不存在则创建，存在则返回异常 `FileExistsError`。 |
|   `a`    | 追加模式，文件指针将会放在文件的结尾，文件不存在则创建，存在则在原文件最后追加内容。 |
|   `+`    | 与`r/w/x/a`一同使用，在原功能基础上增加同时读写功能，带`+`号时，会强制将指针移动至最后。 |

打开模式首先应该选择模式`r/w/x/a/+`，其次选择文件类型`b/t`，当只读打开文本文件时，可以省略。

> 当文件关闭后，再对文件进行读写将产生` I/O`操作错误
>

```python
f = open('test.txt', 'r')
print(f.read())
f.close()
```

#### 4.file对象

file 对象使用 open 函数来创建，下表列出了 file 对象常用的方法。

|            方法             | 说明                                                         |
| :-------------------------: | :----------------------------------------------------------- |
|        `file.next()`        | 返回文件下一行。                                             |
|     `file.read([size])`     | 从指针处开始向下读取指定的字节数，读取后会改变指针位置，如果未给定或为负则读取所有。 |
|   `file.readline([size])`   | 读取整行，包括 "\n" 字符。                                   |
| `file.readlines([sizeint])` | 读取所有行并返回列表，若给定`sizeint>0`，则是设置一次读多少字节，可以用来减轻读取压力。 |
| `file.seek(offset[,whence]` | 设置指针当前位置                                             |
|        `file.tell()`        | 返回指针当前位置。                                           |
|   `file.truncate([size])`   | 删除指针后面的所有内容，截取的字节通过size指定，默认为当前指针位置。 |
|    `file.write(str[,])`     | 将字符串写入文件，返回的是写入的字符长度。                   |
| `file.writelines(sequence)` | 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 |
|         `file.name`         | 属性，返回传入的路径。                                       |
|       `file.encoding`       | 不可修改属性，文本的编码方式。                               |
|         `file.mode`         | 文本的读写模式，可以手动修改。                               |

> file 对象是可迭代的。

大部分函数都比较好理解，这里深入学习一下`file.seek(offset[,whence]`：

- **offset** ：偏移量，也就是代表需要移动偏移的字节数byte，注意，如果是UTF-8的中⽂部分`offset`要是3的倍数。
- **whence：**可选，默认值为 0。给offset参数一个定义，表示要从哪个位置开始偏移；0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。

```python
f = open("./test.txt", mode="r+", encoding="utf-8")
f.seek(0)  # 光标移动到开头
print(f.read())  # 读取内容, 此时光标移动到结尾-蔡贵睡了吗？
print(f.read())  #
f.seek(0)   # 再次将光标移动到开头
print(f.read())  # 读取内容
f.seek(0, 2)  # 将光标移动到结尾
print(f.read())  # 读取内容. 什什么都没有
f.seek(3) # 移动到开头
f.write("张国荣")  # 写⼊入信息. 此时光标在9 中⽂文3 * 3个 = 9
f.seek(0)   # 再次将光标移动到开头
print(f.read()) # 蔡张国荣吗？
f.flush()
f.close()
```

> `r+`将会强制将指针移至结尾。

#### 4.初识上下文语法

with/as语句是常见 try/finally 用法模式的替代方案，同 try/finally语句一样，with/as 语句也被用于定义必须执行的终止或“清理”行为，无论处理步骤中是否发生异常。和try/finally不同的是，with 语句是基于一个对象协议，该协议用于指定在一段代码块前后运行的动作。

对于`open`函数返回的文件对象，还可以使用`with`上下文语法在文件操作完成后自动执行文件对象的`close`方法，以更好地简化代码。注意，并不是所有的对象都可以放在`with`上下文语法中，只有符合**上下文管理器协议**（有`__enter__`和`__exit__`魔术方法）的对象才能使用这种语法，Python标准库中的`contextlib`模块也提供了对`with`上下文语法的支持。

```Python
with open('致橡树.txt', 'r', encoding='utf-8') as file:
    print(file.read())
```

> 关于魔术方法后面再学习，Python 为一些内置工具增加了上下文管理器，例如，自动自行关闭的文件，以及线程锁的自动上锁和解锁，同时程序员也可以用类编写自己的上下文管理器。

#### 5.扩展：二维数据的存读

一组数据在被计算机处理前需要进行一定的组织，表明数据之间的基本关系和逻辑，进而形成“数据的维度”。根据数据的关系不同，数据组织可以分为：一维数据、二维数据和高维数据。一维数据十分常见，任何表现为序列或集合的内容都可以看作是一维数据。二维数据，也称表格数据，由关联关系数据构成，采用二维表格方式组织，对应于数学中的矩阵常见的表格都属于二维数据。高维数据由键值对类型的数据构成，采用对象方式组织，可以多层嵌套。

对于一维数据而言，读取时不必考虑结构，可以直接用`open()`函数读取，对于二维或多维数据则需要对读取或存储的结果进一步处理。

```python
# 二维数据的存储
ls = [
    ['指标', '2014年', '2015年', '2016年'],
    ['居民消费价格指数', '102', '101.4', '102'],
    ['食品', '103.1', '102.3', '104.6'],
    ['烟酒及用品', '994', '102.1', '101.5']
]
# 采用遍历循环和字符串的join0方法相结合
f = open('./cip.csv','w')
for row in ls:
    f.write(','.join(row)+'\n')
f.close()

# 二维数据的读取
f = open('./cip.csv','r')
ls_ = []
for line in f:
    ls_.append(line.strip('\n').split('，'))
print(ls_)  # [['指标,2014年,2015年,2016年'], ['居民消费价格指数,102,101.4,102'], ['食品,103.1,102.3,104.6'], ['烟酒及用品,994,102.1,101.5']]
f.close() 
```

