# 一、Zookeeper
## 01.ZooKeeper 适合哪些应用场景？
ZooKeeper 适用于以下应用场景：

1. 分布式服务注册与订阅：在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就需要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的服务注册与订阅，如 Dubbo。
2. 分布式配置中心：发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZooKeeper 节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。
3. 命名服务：在分布式系统中，通过命名服务客户端应用能够根据指定名字来获取资源、服务地址和提供者等信息。
4. 分布式锁：这个主要得益于 Zookeeper 为我们保证了数据的强一致性。
5. 数据发布和/订阅：主要的一个场景，比如配置中心。
6. 负载均衡：能够基于域名服务，进行应用的负载，从而达到请求负载到各个应用中。
7. 分布式协调/通知：对于一个在多台机器部署运行的应用上，通常都需要一个协调者来控制整个系统的运行流程。
8. 集群管理：在集群环境中，机器和应用都是分散着进行部署，每次进行服务的上下线升级的过程中，都要手动进行集群的管理，这样造成人做的事比较重复性，并且也比较麻烦容易出错。
9. Master选举。
10. 分布式队列。
## 02.简述什么是Zookeeper ？
Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。Zookeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
## 03.简述Zookeeper 目录结构和作用 ？
Zookeeper的目录结构是基于层次型的目录树，它对树中的节点进行有效管理，从而可以设计出多种多样的分布式的数据管理模型。Zookeeper的作用主要是用来维护和监控存储的数据的状态变化，通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。它并不是用来专门存储数据，而是用于维护和监控数据的状态变化。
## 04.简述Zookeeper的工作原理 ？
Zookeeper的工作原理主要基于原子广播机制，实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式和广播模式。当服务启动或者在领导者崩溃的时候，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步之后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。在广播模式下，当一个server加入zookeper服务中，它会在恢复模式下启动，发现leader并和leader进行状态的同步，待到同步结束，它也参与消息广播。Zookeeper服务一直维持在Broadcast状态，直到leader崩溃了或者leader失去了大部分的follower。
## 05.简述zoo.cfg 配置项目和对应的作用 ?
Zoo.cfg配置文件是Zookeeper的核心配置文件，其中可以配置的参数有：

1. clientPort：用于配置当前服务器对客户端暴露的端口，一般配置为2181，无默认值。
2. dataDir：用于配置Zookeeper服务器存储快照文件(Zookeeper 节点数据)的目录，无默认值。
3. dataLogDir：用于配置服务器存储事务日志文件的目录，有默认值dataDir，但是建议将两个目录分别配置，防止磁盘的并发读写，影响服务器性能。可将其配置在一个单独的磁盘上。
4. tickTime：心跳时间，用于配置服务器最小时间的单位，默认值3000ms，心跳检测时间通常是该单位的倍数。如客户端与服务端之间的会话超时时间在2tickTime~20tickTime之间。
5. initLimit：用于配置leader服务器等待Follower服务器启动，并完成数据同步的时间，默认为10，表示10*tickTime。
6. syncLimit：用于配置leader服务器和Follower服务器之间进行心跳检测的最大延时时间，默认为5，表示5*tickTime。
7. minSessionTimeout和maxSessionTimeout：用于服务端对客户端会话超时时间的限制，也就是客户端自定义的超时时间必须在minSessionTimeout~maxSessionTimeout内，其默认为分别为2和20，时间表示为2tickTime~20tickTime。
8. maxClientCnxns：从socket层面限制单个客户端和单台服务器之间的最大并发连接数，即以IP地址粒度来进行连接数的限制，如果为0，表示不作限制，默认为60。
9. clientPortAddress：针对多网卡的机器，该参数允许为每个IP地址指定不同的监听端口。
10. server.id=host:port:port：用于配置组成Zookeeper集群的机器列表，其中id为serverId，与myid文件中的值对应。第一个端口用于指定Leader服务器和Follower服务器进行运行时通信和数据同步所使用的端口，第二个端口用于进行Leader选举过程中的投票通信。
11. autopurge.snapRetainCount：用于配置Zookeeper在自动清理的时候需要保留的快照数据文件数量和对应的事务日志文件，默认为3，自定义值小于3也会取值3。

这些参数可以用来配置Zookeeper服务器的各个方面的行为，包括端口号、数据存储目录、心跳检测机制、集群模式等。在具体使用时，需要根据实际情况进行配置。
## 06.请列举Zookeeper的常用命令 ？
Zookeeper的常用命令包括：

1. 启动Zookeeper服务：bin/zkServer.sh start
2. 查看 Zookeeper状态：bin/zkServer.sh status
3. 停止 Zookeeper服务：bin/zkServer.sh stop
4. 重启 Zookeeper服务：bin/zkServer.sh restart
5. 连接服务器：zkCli.sh -server 192.168.1.2:2181
6. 查看根目录：ls /
7. 创建节点：create /zk myDate
8. 查看节点内容： get /zk
9. 设置节点内容： set /zk myBook
10. 删除节点： delete /zk

这些命令可以在Zookeeper的CLI环境下使用，用于管理Zookeeper服务器的状态、连接、节点创建、内容查看、修改和删除等操作。
## 07.列举Zookeeper服务启动日志的组成结构 ？
Zookeeper服务启动日志的组成结构包括三类日志：事务日志、快照日志和系统日志。

1. 事务日志：在Zookeeper系统正常运行过程中，针对所有的更新操作，在返回客户端更新成功响应前，Zookeeper会保证已经将本次更新操作的事务日志写到磁盘上，只有这样，整个更新操作才会生效。事务日志为二进制文件，不能通过vim等工具直接访问，可以通过Zookeeper自带的功能文件读取事务日志文件。
2. 快照日志：Zookeeper服务器会产生三类日志其中就有快照日志，它是指在Zookeeper运行过程中，将系统状态的快照以文件形式记录下来，可以用于系统恢复或者备份。
3. 系统日志：Zookeeper的系统运行日志可以通过三个位置来进行设置，一是log4j.properties文件中通过zookeeper.log.dir=.来设置，这里的'.'指的是zkServer.sh所在的目录；二是在zkEnv.sh文件中通过ZOO_LOG_DIR="$ZOOKEEPER_PREFIX/logs"来设置；三是在zkServer.sh文件中通过ZOO_LOG_FILE=zookeeper-$USER-server-$HOSTNAME.log _ZOO_DAEMON_OUT="$ZOO_LOG_DIR/zookeeper-$USER-server-$HOSTNAME.out"来指定。

这些日志记录了Zookeeper服务器的运行状态、更新操作、系统状态等信息，可以用于系统监控、调试和恢复等操作。
## 08.简述Zookeeper基本数据模型和存储结构 ？
Zookeeper的基本数据模型和存储结构可以概括如下：

1. 数据模型：Zookeeper的数据模型类似于一个文件系统，具有一个层次的命名空间，使用斜杠“/”进行分隔。但它与标准文件系统不同，标准文件系统由文件夹和文件组成，而Zookeeper由节点（Znode）组成，每个节点都可以拥有子节点。Znode是Zookeeper中的基本单位，每个节点都有一个路径，并且可以存储数据。
2. 存储结构：Zookeeper的存储结构采用了类似于目录树的形式，从根节点（/）开始，可以创建子节点，并在子节点下继续创建下一级节点。这种树形结构使得Zookeeper可以方便地存储和管理大量的数据。
3. 数据存储方式：在Zookeeper中，每个节点（Znode）都有默认能够存储1MB的数据。每个Znode都可以通过其路径唯一标识。
4. 节点类型：Zookeeper有两种类型的节点，分别是临时节点和永久节点。临时节点依赖于创建它们的会话，一旦会话结束，临时节点将会被自动删除。临时节点不允许拥有子节点。

## 09.Zookeeper客户端与服务端之间的的连接称之为什么？
Zookeeper客户端与服务端之间的连接称为会话（session）。在Zookeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。
## 10.简述Zookeeper的watcher机制 ？
Zookeeper的watcher机制是一种实现分布式数据发布/订阅功能的方式，它允许客户端向服务端注册一个watcher监听，当服务器的一些特定事件触发这个watcher时，就会向指定客户端发送一个事件通知。这种机制可以帮助实现分布式的通知功能。在Zookeeper中，watcher机制主要包括客户端线程、客户端WatchManager和ZooKeeper服务器三部分。客户端向服务端注册watcher，当服务器的一些特定事件触发了这个watcher，就会向指定客户端发送一个事件通知。触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。总的来说，Watcher机制可以概括为以下三个过程：客户端向服务端注册Watcher、服务端事件发生触发Watcher、客户端回调Watcher得到触发事件情况。
## 11.Zookeeper集群不得少于几台服务器，集群规则是什么？
Zookeeper集群不得少于三台服务器，因为Zookeeper通过存活节点数数量是否大于总节点数一半来判断服务是否可以。例如三个节点，挂掉了2个表示整个集群挂掉，而用偶数4个，挂掉了2个，剩下的2个节点并没有超过半数，因此也会挂掉。集群最好是在不同的物理机上，本案例因生产环境因素，搭建在一台物理机上，因此也叫伪集群，但差别不是很大，只是ip地址不同。
## 12.Zookeeper有哪几种几种部署模式？
Zookeeper有三种部署模式，分别是单机模式、伪集群模式和集群模式。

1. 单机模式：一般用来检验Zookeeper基础功能，熟悉Zookeeper各种基础操作及特性。
2. 伪集群模式：在单台机器上部署集群，方便在本地验证集群模式下的各种功能。
3. 集群模式：一般在生产环境使用，具备一致性、分区容错性。
## 13.请阐述Zookeeper是如何选取主leader的？
Zookeeper在集群模式下，是通过一种称为Zab协议的机制来选取主leader的。Zab协议有两种模式，分别是恢复模式和广播模式。当服务启动或者在领导者崩溃的时候，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步之后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。在广播模式下，当一个server加入zookeper服务中，它会在恢复模式下启动，发现leader并和leader进行状态的同步，待到同步结束，它也参与消息广播。Zookeeper服务一直维持在Broadcast状态，直到leader崩溃了或者leader失去了大部分的follower。

在Zab协议中，每个服务器都会发出一个投票。由于是初始情况，服务器1和服务器2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，然后各自将这个投票发给集群中其他机器。之后，每个服务器会接受来自各个服务器的投票。在这个过程中，服务器会判断收到的投票是否合法，并根据一定的规则进行投票的确认和转发。最终，会选出一个主leader，其他服务器则会成为follower。

需要注意的是，Zookeeper在选举主leader时并不是基于节点ID的大小进行排序的，而是通过一种基于时序的机制来选取主leader。具体来说，每个服务器在发出投票时都会携带一个时间戳，这个时间戳是服务器在启动时获取的。当其他服务器收到投票后，会根据时间戳的大小来判断是否转发这个投票。时间戳最大的服务器会被选为主leader。如果多个服务器的投票时间戳相同，则按照节点的ID进行排序，ID最小的服务器会被选为主leader。
## 14.Zookeeper是如何保证事务的顺序一致性的？
Zookeeper通过多种机制保证了事务的顺序一致性：

1. 顺序执行：Zookeeper的所有写操作都会被服务器顺序执行，无论这些操作是否来自同一个客户端。这意味着客户端发起的每次写操作（如创建节点、设置节点数据或删除节点等）都会在严格的先后顺序下按顺序执行。
2. 唯一性约束：Zookeeper通过路径名确保所有写请求都是唯一的。对于相同的节点路径和数据，只允许一个客户端成功创建或更新该节点，其他客户端会收到NodeExistsException或版本冲突（version mismatch）等异常信息。
3. 数据版本控制：Zookeeper中的每条记录（包括znode、数据等）都有一个版本号，它是由一个递增的计数器生成的。如果客户端试图使用过期版本号更新或删除记录，则会导致版本号冲突而失败。
4. 会话控制：当客户端建立与Zookeeper服务器的连接时，将分配一个唯一的会话ID。在会话有效期内，客户端可以发送读写请求，在会话超时后，Zookeeper将关闭与其关联的会话并清除已经申请的临时节点等数据。
5. 仅序列化的访问：对于每个znode的所有操作都是通过一个全局有序的更新序列（transaction log）进行的，客户端只会看到该全局序列的一个后缀。因此，对数据和状态的读取操作必须以相同的方式和序列化顺序执行。
6. ZAB协议：ZAB协议是Zookeeper自主开发的一种原子广播协议。它将Zookeeper服务集群中的每个服务器划分为两类:Leader（领导者）和Follower（跟随者）。Leader负责处理客户端请求并维护系统状态，而Followers则负责复制Leader的状态。当客户端发送一个事务请求到Zookeeper集群时，Leader会将该请求附加到自己的事务日志中，并广播给所有的Followers。这些Followers会按照Leader发送的顺序逐个执行事务请求。
7. 提案编号：每个事务请求在被广播前，会被分配一个唯一的递增编号，称为提案编号。这个编号在整个集群中都是唯一的，用于标识事务的顺序。
8. Quorum和多数派决策：Zookeeper采用了Quorum的思想来保证顺序一致性。Quorum是指在一个分布式系统中，至少需要多少个节点达成一致才能进行下一步操作。通常情况下，Zookeeper集群的Quorum数量为奇数，以确保有足够的节点来解决冲突。多数派决策是指在一个Quorum中，大多数节点必须就某个提案达成一致，才认为这个提案是提交的。
9. 提交过程：一旦多数节点接受了某个提案，Leader就会将该提案标记为“已提交”。一旦提交，提案所对应的操作就会被应用到状态机上，从而实现一致性的状态更新。

综上所述，Zookeeper通过多种机制共同保证了事务的顺序一致性。
## 15.请列举身份认证的5种类型schema?
以下是身份认证的5种类型：

1. 个人信息身份认证：这种类型通常基于个人的基本信息，如姓名、生日、性别、身份证号码等。这是最常见的身份认证方式，通常用于个人信息的核实和确认。
2. 密码身份认证：这种方式基于用户设置的密码进行身份认证。在登录或进行其他身份认证操作时，用户需要输入正确的密码才能通过认证。
3. 动态口令身份认证：这种认证方式通常采用动态口令牌或其他动态密码生成设备，用户在认证时需要输入动态生成的密码。这种认证方式增加了安全性，防止密码被猜测或窃取。
4. 生物特征身份认证：这种认证方式基于个人的生物特征信息，如指纹、虹膜、面部特征等。这种认证方式具有很高的安全性，但需要使用专门的生物特征识别设备。
5. 数字证书身份认证：这种方式使用数字证书对用户进行身份认证。数字证书是一种电子文件，包含用户的身份信息和密钥信息，用于证明用户的身份。在进行网络交易或登录时，用户需要出示有效的数字证书才能通过认证。

这些身份认证类型可以单独使用，也可以结合使用，以提高身份认证的安全性和准确性。选择哪种身份认证方式取决于应用场景的安全需求和用户设备的支持情况。
## 16.请描述 Zookeeper 的通知机制是什么？
Zookeeper 的通知机制是一种观察者（watcher）模式，允许客户端在关心的目录节点上设置观察，当节点发生改变时，Zookeeper 会通知设置过观察的客户端。

通知机制是异步回调的触发机制，Zookeeper 支持在 getData()、getChildren() 和 exists() 操作中设置 watcher，当被观察服务端的 znode 节点有变更，那么 watcher 就会被触发，这个 watcher 所属的客户端就会收到一个通知包，告知节点已经发生变化。
## 17.请列举Znode节点有哪些类型 ？
Zookeeper 中的 Znode 节点有以下四种类型：

1. PERSISTENT（永久节点）：从一开始被创建就会永久存在，直到被主动删除。这种类型的节点不会因为客户端会话的断开而被删除。
2. PERSISTENT_SEQUENTIAL（永久有序节点）：与 PERSISTENT 类似，唯一的区别是节点名会被追加一个单调递增的十进制序号。
3. EPHEMERAL（临时节点）：这种类型的节点被客户端创建，当客户端断开连接时，该节点就会被删除。
4. EPHEMERAL_SEQUENTIAL（临时有序节点）：与 EPHEMERAL 类似，但节点名会被追加一个单调递增的十进制序号。当客户端断开连接时，该节点同样会被删除。
## 18.请问Znode节点状态stat的属性 ？
Znode节点状态stat的属性包括：

1. cZxid：数据节点创建时的事务id。
2. mZxid：数据节点最后一次更新的事务id。
3. pZxid：数据节点的子节点最后一次被修改时的事务ID。
4. ctime：数据节点创建时的时间。
5. mtime：数据节点最后一次更新的时间。
6. dataVersion：节点数据的更改次数。
7. cversion：子节点的更改次数。
8. aclVersion：节点的ACL（权限列表）的更改次数。
9. ephemeralOwner：如果znode是临时节点，则这是znode所有者的session ID。如果znode不是临时节点，则该字段设置为0。
10. dataLength：这是znode数据字段的长度。
## 19.请简述Znode的结构 ?
Znode是Zookeeper中的节点，它兼具文件和目录两种特性。每个Znode都维护着数据、元信息、ACL（访问控制列表）和时间戳等数据结构。

每个Znode由三部分组成：

1. stat：维护Znode的状态信息，包括版本号、权限等信息。
2. data：与该Znode关联的数据。
3. children：该Znode下的子节点。

此外，Zookeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储。相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。
## 20.简述watcher使用场景 ？
Watcher的使用场景包括但不限于以下几种情况：

1. 数据发布/订阅：在分布式环境中，Zookeeper允许发布者将数据发布到节点上，供订阅者进行数据订阅，实现配置信息的集中式管理和数据的动态更新。这种模式有两种设计模式，推模式和拉模式。
2. 集群状态感知：Watcher可以用于感知集群中的变化，例如，当有新的服务器加入集群时，可以在Zookeeper的特定节点上设置Watcher，一旦集群中有了变化，Watcher就会被触发并通知客户端。
3. 分布式通知：Watcher可以用于实现分布式通知，例如，当一个分布式任务完成时，可以在Zookeeper的特定节点上设置Watcher，一旦任务完成，Watcher就会被触发并通知客户端。
4. 配置管理：Watcher可以用于配置管理，例如，可以在Zookeeper的特定节点上保存配置信息，一旦配置信息发生变化，Watcher就会被触发并通知客户端。

总的来说，Watcher适用于需要监控分布式系统中特定事件或状态变更的场景。
## 21.简述Zookeeper的监听原理 ？
Zookeeper的监听原理基于观察者模式实现。客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节点增加删除）时，Zookeeper会通知客户端。

具体来说，客户端在注册监听器时会将节点路径和监听器信息传递给服务端。服务端在接收到客户端的请求后会将节点路径和客户端连接信息存储在服务端的WatchManager中。当客户端的目录节点发生变化时，服务端会向客户端发送事件通知，客户端在接收到通知后执行监听器的回调方法。

这种监听机制可以保证Zookeeper保存的任何数据改变都能快速响应到监听了该节点的应用程序中。
## 22.请解释Zookeeper保证数据一致性（详述） ？
Zookeeper通过以下几种方式来保证数据一致性：

1. 原子性：所有的更新操作都会被应用到所有节点上，因此它们在所有节点上保持一致性。
2. 可靠性：一旦一个更新操作被应用，它将会持久化保存下来，并且在出现故障时保证数据的恢复。
3. 顺序性：来自客户端的更新将严格按照客户端发送的顺序处理。
4. 单一视图：无论客户端连接到哪个服务器，看到的都是一样的视图。
5. 实时性：在特定的一段时间内，任何系统的改变都能被客户端看到，或者被监听到。

此外，Zookeeper内部使用原子广播协议（Zab）作为其一致性复制的核心，并通过对服务端请求的排序达到数据一致性的保障要求。在故障恢复阶段的数据同步方面，leader为每个follower准备一个队列，将没有被同步的事务以proposal请求形式放入队列，然后对每个事务请求追加一个commit请求，表示该事务被提交，完成数据的同步。
## 23.简述什么是ZAB协议并且解释其实现原理 ?
ZAB协议是Zookeeper Atomic Broadcast（Zookeeper原子广播）的简称，是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。ZAB协议是Zookeeper保证数据一致性的核心算法，借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法，它是特别为Zookeeper设计的支持崩溃恢复的原子广播协议。

ZAB协议包含两种基本模式，分别是崩溃恢复和原子广播。在崩溃恢复模式下，ZAB协议通过选举产生新的leader，并由leader负责同步数据到其他follower节点。在原子广播模式下，ZAB协议将客户端的写操作转化为事务提案，并由leader节点将提案广播给所有follower节点，等待所有follower节点的反馈。只要超过半数follower节点反馈OK，Leader节点就会向所有的follower服务器发送commit消息，即将leader节点上的数据同步到follower节点之上。

在ZAB协议中，整个Zookeeper集群中只有一个节点即Leader将客户端的写操作转化为事物（或提议proposal）。Leader节点再数据写完之后，将向所有的follower节点发送数据广播请求（或数据复制），等待所有的follower节点反馈。在ZAB协议中，只要超过半数follower节点反馈OK，Leader节点就会向所有的follower服务器发送commit消息。即将leader节点上的数据同步到follower节点之上。
## 24.Zookeeper怎么保证主从节点的状态同步?
Zookeeper通过Zab协议来保证主从节点的状态同步。Zab协议有两种模式，分别是恢复模式和广播模式。

在恢复模式中，当服务启动或者在领导者崩溃后，Zab进入恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。

在广播模式下，一旦leader已经和多数的follower进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个server加入ZooKeeper服务中，它会在恢复模式下启动，发现leader，并和leader进行状态同步。待到同步结束，它也参与消息广播。
## 25.详细阐述什么是Paxos算法 ？
Paxos算法是一种基于消息传递的一致性算法，由莱斯利·兰伯特（Leslie Lamport）于1990年提出。它被广泛应用于分布式系统中的一致性问题，如分布式数据库、分布式存储系统等。

Paxos算法的目标是在一个由多个节点组成的分布式系统中，就某个值达成一致性。它通过多个阶段的消息交换和投票来实现一致性。在Paxos算法中，节点被分为提议者（proposer）、接受者（acceptor）和学习者（learner）。提议者负责提出值的提案，接受者负责接受提案并投票，学习者负责学习已经达成一致的值。

Paxos算法的执行过程可以简要概括为以下几个步骤：

1. 提案阶段（Prepare Phase）：提议者向接受者发送准备请求，接受者根据请求的编号决定是否接受该提案。
2. 接受阶段（Accept Phase）：如果接受者接受了提案，它会向其他接受者发送接受请求，请求包含了接受的提案编号和值。
3. 学习阶段（Learn Phase）：一旦一个提案被足够多的接受者接受，学习者就可以学习到该提案的值。

Paxos算法通过多轮的消息交换和投票，保证了分布式系统中的节点最终能够达成一致的值。它具有高度的容错性和可扩展性，能够应对节点故障和网络延迟等问题。然而，Paxos算法本身比较复杂，理解和实现起来都有一定的难度，因此通常会使用一些基于Paxos算法的库或框架来简化分布式系统中的一致性实现，如ZooKeeper、etcd等。
## 26.请列举ZAB和Paxos算法的联系与区别？
ZAB和Paxos算法的联系与区别如下：

联系：

1. ZAB和Paxos都存在于一个类似于leader进程的角色，负责协调follower进程的运行。在这个过程中，leader进程都会等待超过半数的follower做出正确的反馈后，才会将一个提议进行提交。
2. 在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，这个概念在Paxos算法中被称为Ballot。
3. ZAB协议和Paxos算法都采用了类似于“拜占庭将军问题”的解决方案，即通过多数派投票来达成一致。

区别：

1. 设计目标：ZAB协议的目标是构建一个高可用的分布式数据主备系统，而Paxos算法的目标是构建一个分布式的一致性状态机系统。
2. 工作流程：在ZAB协议中，新的Leader会确保存在过半的Follower已经提交了之前的Leader周期中的所有事务Proposal。而在Paxos算法中，新选举产生的主进程会进行两个阶段的工作，第一阶段称为读阶段，新的主进程和其他进程通信来收集主进程提出的提议，并将它们提交。第二阶段称为写阶段，当前主进程开始提出自己的提议。
3. 系统结构：ZAB协议在Paxos基础上添加了同步阶段，此时，新的Leader会确保存在过半的Follower已经提交了之前的Leader周期中的所有事务Proposal。

总的来说，ZAB和Paxos算法都是为了解决分布式系统中的一致性问题而设计的，但它们在实现方式、工作流程以及系统结构上存在一些差异。
## 27.Zookeeper负载均衡和Nginx负载均衡有什么区别？
Zookeeper负载均衡和Nginx负载均衡的区别主要体现在以下三个方面：

1. 负载均衡的目的：Zookeeper负载均衡的目的是通过将服务注册到Zookeeper注册中心，建立一个树形的服务结构，然后通过查找能提供所需服务的服务器列表，根据负载均衡算法从中选取一台服务器进行连接。其主要用于实现服务的动态发现和负载均衡。而Nginx负载均衡的主要目的是将多个web server配置到Nginx中，用户访问Nginx时，就会自动被分配到某个web server upstream。
2. 实现方式：Zookeeper负载均衡的实现思路是将每个服务注册到Zookeeper注册中心，每台服务器知道自己是属于哪个服务，在服务器启动时，自己向所属服务进行登记，这样，一个树形的服务结构就呈现出来了。服务的调用者到注册中心里面查找能提供所需服务的服务器列表，然后自己根据负载均衡算法，从中选取一台服务器进行连接。而Nginx的负载均衡配置非常简单，把多个web server配置到Nginx中，用户访问Nginx时，就会自动被分配到某个web server upstream。
3. 适用场景及优缺点：Zookeeper负载均衡适用于服务数量和服务集群规模较大，需要进行动态服务发现和负载均衡的场景。其优点在于可以实现动态服务发现和负载均衡，并且具有高可用性和可扩展性。但是，随着整个系统的演进，服务的数量会不断增加，每个服务集群中的服务器数量也会增加，这可能会导致配置维护的成本变高，并且存在单点故障的风险。而Nginx负载均衡适用于服务拆分、各个服务独立部署、通过远程调用方式协同工作的场景。其优点在于配置简单、性能高、稳定性好，可以作为反向代理、静态文件服务器等。但是，如果服务规模很大或者需要更复杂的负载均衡策略时，Nginx可能无法满足需求。

总结来说，Zookeeper和Nginx都具有负载均衡功能，但是它们在实现方式、目的以及适用场景和优缺点上有所不同。选择哪种负载均衡方式取决于具体的需求和应用场景。
## 28.简述Zookeeper的CAP理论 ？
Zookeeper的CAP理论是指在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）三者不可兼得。

* 一致性（C）：分布式系统中多个主机之间是否能够保持数据一致性的特性。即当系统数据发生更新操作之后，各个主机中的数据是否仍然处于一致的状态。
* 可用性（A）：系统提供的服务必须一直处于可用的状态，即对于的每一个请求，系统总是可以在有限的时间内对用户做出响应。
* 分区容错性（P）：分布式系统在遇到任何网络分区故障时候，仍然保证对外提供满足一致性和可用性的服务。对于分布式系统来讲，网络环境相对不可控，出现网络分区是不可避免的，因此必须具备分区容错性。但其并不能保证同时一致性与可用性。

CAP原则对于一个分布式系统来说，只能满足其中两项，无法三者兼顾。
## 29.Zookeeper节点宕机如何处理？
在Zookeeper中，如果一个节点宕机，可以采取以下措施：

1. 故障恢复操作：一旦监测到Zookeeper节点宕机，可以执行故障恢复操作，例如重新创建节点、通知相关服务，或者执行其他适当的操作。这取决于具体应用场景。
2. 高可用架构：为了提高Zookeeper的可用性，可以考虑使用Zookeeper的集群，以便在一个节点宕机时其他节点仍然可用。确保Zookeeper集群配置正确，并且有足够的节点来容忍故障。在Zookeeper集群中，当一个节点宕机时，其上的数据副本将仍然存在，因此数据不会丢失。如果是一个Follower节点宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的；如果是一个Leader节点宕机，Zookeeper会选举出新的Leader。
## 30.ZooKeeper 集群中个服务器之间是怎样通信的？
在ZooKeeper集群中，各个服务器之间通过TCP协议进行通信。每个服务器都会创建一个叫做LearnerHandler的实体，它主要负责Leader和Follower之间的网络通讯，包括数据同步、请求转发和Proposal提议的投票等。

ZooKeeper集群通信采用的是主从模式，其中包括一个Leader节点和多个Follower节点。在正常运作的情况下，Leader节点负责处理客户端请求和事务处理，而Follower节点则负责与Leader节点进行通信并同步数据。当一个Follower节点变成了新的Leader，它会将Follower的数据复制到新的Leader上，并更新系统状态。

ZooKeeper集群中的每个节点都可以成为Leader，当一个Follower节点发现Leader节点失效时，它会通过选举算法选举出新的Leader。选举过程中，各个Follower节点会互相发送消息来保持状态的同步，包括心跳消息、请求消息和响应消息等。

ZooKeeper提供了基于类似Linux文件系统的目录节点树方式的数据存储，即分层命名空间。这种数据存储方式使得ZooKeeper可以很方便地管理分布式系统中的各种配置信息、命名服务、状态管理等等。
## 31.请列举ZooKeeper中使用watch的注意事项有哪些？
在使用ZooKeeper中的watch时，需要注意以下几点：

1. Watches通知是一次性的，必须重复注册。这意味着如果想要重新获取某个节点的数据变化通知，需要再次对该节点进行watch注册。
2. 当发生CONNECTIONLOSS时，只要在session_timeout之内再次连接上（即不发生SESSIONEXPIRED），那么这个连接注册的watches依然在。这意味着，即使在连接丢失后，只要在session_timeout时间内重新连接上ZooKeeper，之前注册的watch请求仍然有效。
3. 节点数据的版本变化会触发NodeDataChanged。这包括但不限于setData()方法执行后，只要内容与之前不一致，都会触发NodeDataChanged通知。因此，需要注意处理这种数据版本变化的情况。
4. 如果对某个节点注册了watch，但是节点被删除了，那么注册在这个节点上的watches都会被移除。因此，如果需要持续获取某个节点的数据变化通知，需要确保该节点在watch注册期间不会被删除。
5. 同一个zk客户端对某一个节点注册相同的watch，只会收到一次通知。这意味着如果重复注册相同的watch请求，可能会错过一些数据变化通知。
6. Watcher对象只会保存在客户端，不会传递到服务端。这意味着，当客户端重新连接ZooKeeper时，之前注册的watch请求需要重新注册。同时，不同client在不同时刻获取watch事件和操作返回值可能存在时间差异。因此，需要考虑到这种网络延迟或其他因素对获取watch事件和操作返回值的影响。
## 32.客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？
是的，其他客户端可以立即获取到更新的数据。在ZooKeeper中，当一个客户端修改了某个节点的数据后，会触发一个watch通知给所有对该节点设置watch的客户端。这些客户端会立即收到更新后的数据。因此，只要在客户端修改数据后，其他客户端就可以立即获取到最新的数据。
## 33.整体阐述下请简述Zookeeper的选举机制 ？
Zookeeper的选举机制主要涉及到服务器角色分配和数据同步两个方面。

在Zookeeper集群中，有leader和follower两种角色。Zookeeper默认的算法是FastLeaderElection，通过投票数大于半数则胜出。每个节点先投自己一票，并向其他节点发送投票信息，包括自己的myid、zxid和选举周期（epoch）。 节点收到其他节点的投票信息后，首先比较各自的epoch值。如果其他节点的epoch值比自己的小，则忽略该节点的投票信息，如果epoch值相等，则比较zxid的值，选取zxid值最大的节点作为leader。 如果没有节点的zxid值比自己的大，则选取myid值最大的节点作为leader。如果myid值也相等，则随机选择一个节点作为leader。

同时，Zookeeper还采用了“过半原则”，即只有大多数节点都能够响应才能够继续进行选举，否则选举将会失败。这样可以避免脑裂（split-brain）问题。

另外，Zookeeper中每个节点都有一个zxid（ZooKeeper Transaction Id）标识其所提交的事务，zxid值越大，表示该节点提交的事务越多，也就意味着其数据状态更为更新。节点还有一个myid，是一个数字，用来唯一标识该节点。

总的来说，Zookeeper的选举机制是为了确保集群的高可用性，使得即使部分节点宕机，集群仍然能够正常运行。
## 34.解释ZooKeeper下service有几种工作状态 ？
在ZooKeeper中，service有四种工作状态，分别是LOOKING、FOLLOWING、LEADING和OBSERVING。

1. LOOKING：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。
2. FOLLOWING：跟随者状态。表明当前服务器角色是Follower。
3. LEADING：领导者状态。表明当前服务器角色是Leader。
4. OBSERVING：观察者状态。表明当前服务器角色是Observer。

这些状态可以帮助ZooKeeper更好地管理集群中的服务，确保其高可用性和稳定性。
## 35.简述ZooKeeper 分布式锁怎么实现的？
ZooKeeper 分布式锁的实现基于其实现分布式一致性的机制。以下是其实现分布式锁的大致步骤：

1. 在所有需要加锁的节点上创建一个临时有序节点C。如果创建成功，节点C的名称会返回。
2. 获取当前节点下的所有临时节点，利用 ZooKeeper 节点的顺序一致性，找到最小的节点就算获取到了锁。
3. 比较临时节点中的最小节点的名称和创建的节点C的名称，如果匹配成功，表示当前节点就是最小节点，就意味着获取到了锁。
4. 如果当前节点不是最小节点，需要获取比当前节点顺序小的所有节点的集合。
5. 如果该集合不为空，获取这个集合节点中的最后一个节点B。然后让B去监听它的上一个节点A，当A的会话超时或者A节点被删除（释放）时，B就会获取到锁；同理，当B被删除或者会话超时时，C就会获取到锁。
6. 在执行完业务逻辑操作后，删除节点锁就会被释放，下一个节点就能获取到锁。
## 36.简述ZooKeeper 的持久化机制 ?
ZooKeeper的持久化机制涉及到数据存储和事务日志的持久化。

首先，ZooKeeper的数据存储有两种方式：内存数据库和磁盘数据库。默认情况下，ZooKeeper使用内存数据库，从磁盘加载先前保存在内存中的数据。一旦开始处理客户端请求，它会将所有更改记录在内存中，并异步将这些更改写入磁盘。这种机制确保了数据的实时性。另一方面，磁盘数据库作为可选的数据存储方式，将ZooKeeper数据写入磁盘，并在启动时读取磁盘上的数据。在写入磁盘时，ZooKeeper使用了一种称为“快照”的机制，该机制会将整个ZooKeeper数据树保存到磁盘上的一个文件中。

其次，ZooKeeper的事务日志持久化是通过记录每一次事务操作到日志文件实现的。这些日志文件对于数据的恢复和事务的完整性非常重要。每当有一个新的事务操作时，ZooKeeper就会将这个操作记录到一个新的日志文件中，文件名通常包含一个特定的ZXID（表示该文件起始的事务ID）。这种日志文件格式有助于在需要时重放这些操作，从而恢复数据。

此外，为了加快数据恢复的速度，ZooKeeper还提供了对树结构和session信息进行数据快照持久化的操作。数据快照会记录ZooKeeper服务器上某一时刻的全量内存数据内容，并写入指定磁盘文件中。这些快照文件的格式通常包含一个特定的ZXID，用于确定数据恢复的起始点。

总的来说，ZooKeeper的持久化机制确保了数据的可靠性和实时性，同时提供了快速恢复数据的功能。
## 37.Zookeeper 是如何解决脑裂问题的？
Zookeeper通过以下方式解决脑裂问题：

1. Quorums（法定人数）：例如，在3个节点的集群中，Quorums = 2，这意味着集群可以容忍1个节点失效，这时候还能选举出1个leader，集群还可用。在4个节点的集群中，Quorums = 3，Quorums要超过3，相当于集群的容忍度还是1，如果2个节点失效，那么整个集群还是无效的。
2. Redundant communications（冗余通信）：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。
3. Fencing（共享资源）：比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是leader，看不到共享资源的，就不在集群中。
## 38.Zookeeper脑裂是什么原因导致的？
Zookeeper脑裂可能是由于多种原因导致的，其中常见的原因包括：

1. 网络故障：例如，集群中各个节点之间的心跳线链路发生故障，导致节点之间的通信中断。这种情况下，各个节点无法正常地与其他节点进行通信，就会出现脑裂的问题。
2. Zookeeper客户端实现错误：例如，客户端在处理网络分区故障时，未能正确处理选举过程，导致出现脑裂问题。
3. Zookeeper集群配置错误：例如，集群中的Quorums设置不合理，或者集群中的节点数量不足，导致无法正常进行选举，从而出现脑裂问题。
4. 其他原因：例如，硬件故障、软件Bug等也可能导致脑裂问题的出现。

为了解决Zookeeper脑裂问题，可以采取以下措施：

1. 确保网络连接的稳定性：通过优化网络配置、增加网络带宽等方式，减少网络故障的发生。
2. 优化Zookeeper客户端实现：针对客户端实现中的错误进行修复和优化，避免出现脑裂问题。
3. 合理配置Zookeeper集群：根据实际需求和集群规模，合理设置Quorums等参数，确保集群的可用性和稳定性。
4. 定期检查和更新硬件、软件：及时发现并修复硬件故障、修复软件Bug等，减少脑裂问题的发生。
## 39.简述Zookeeper中的脑裂问题 ？
Zookeeper中的脑裂问题是指，在Zookeeper集群中，多个节点同时认为自己是leader，而其他节点则认为自己是follower，导致整个集群无法正常工作的情况。

脑裂问题通常是由于网络故障、配置错误或其他异常情况导致的。例如，在Zookeeper集群中，各个节点之间需要保持通信，如果网络出现故障或通信链路出现问题，导致节点之间的通信中断，就可能出现脑裂问题。此外，如果配置不当，例如Quorums设置不合理或集群中的节点数量不足，也可能导致脑裂问题的出现。

为了解决脑裂问题，可以采取以下措施：

1. 确保网络连接的稳定性，减少网络故障的发生。
2. 优化Zookeeper客户端实现，避免出现脑裂问题。
3. 合理配置Zookeeper集群，根据实际需求和集群规模，合理设置Quorums等参数，确保集群的可用性和稳定性。
4. 定期检查和更新硬件、软件，及时发现并修复硬件故障、修复软件Bug等，减少脑裂问题的发生。

总之，脑裂问题是Zookeeper集群中一个比较复杂的问题，需要针对具体的情况进行分析和处理。通过采取相应的措施，可以有效地解决脑裂问题，确保Zookeeper集群的可用性和稳定性。
## 40.Zookeeper对节点的watch监听通知是永久的吗？
**Zookeeper对节点的watch监听通知不是永久的**。它是一次性的，也就是说，当某个事件触发时，Zookeeper只会发送一次通知给注册了watch的客户端。如果需要持续监听，客户端需要再次对节点进行watch注册。
## 41.简述Zookeeper和Dubbo的关系 ？
Zookeeper和Dubbo是两个相互依存的关系：

1. Zookeeper是一个分布式协调服务，被用于构建分布式系统的基础设施，提供了分布式锁、分布式队列等机制，并可以被用于服务的注册与发现、配置中心等场景。Dubbo则是一个高性能的JavaRPC框架，用于提供服务的管理和调用机制。
2. Dubbo将自身作为一个服务，通过Zookeeper将自身注册到Zookeeper集群中，并在消费方从Zookeeper中发现并订阅服务。Zookeeper则提供一个平台，支持Dubbo实现服务的注册、发现、负载均衡和容错等功能。
3. Dubbo对Zookeeper的依赖主要表现在服务注册与发现机制上。Zookeeper的特性，包括负载均衡、资源同步、命名服务等，都被Dubbo借鉴和使用。

总的来说，Zookeeper和Dubbo之间的关系是相互依存的：Dubbo依赖Zookeeper实现服务注册与发现，而Zookeeper也可以通过Dubbo来实现服务治理的能力。
## 42.简述对ZooKeeper对事务性的支持？
ZooKeeper对事务性的支持主要依赖于其四个函数，分别是zoo_create_op_init，zoo_delete_op_init，zoo_set_op_init以及zoo_check_op_init。这些函数在客户端初始化一个operation，并保留这些operations。当准备好一个事务中的所有操作后，可以使用zoo_multi来提交所有的操作，由zookeeper服务来保证这一系列操作的原子性。也就是说只要其中有一个操作失败了，相当于此次提交的任何一个操作都没有对服务端的数据造成影响。 Zoo_multi的返回值是第一个失败操作的状态信号。
## 43.请说明ZooKeeper使用到的各个端口的作用？
ZooKeeper使用的端口主要有三个，分别是2181、3888和2888。

1. 2181端口：主要用于对客户端提供服务。
2. 3888端口：主要用于选举leader。
3. 2888端口：主要用于集群内机器通讯，特别是在Leader监听此端口。

在部署时，单机单实例只需端口不被占用即可。如果是单机伪集群（如在单机上部署多个实例），则三个端口必须修改且组组不一样。例如，myid1 : 2181,3888,2888，myid2 : 2182,3788,2788，myid3 : 2183,3688,2688。如果是集群环境（一台机器部署一个实例），其基数应大于等于3，例如3、5、7等，但不宜太多，因为机器多了可能导致选举和数据同步耗时长，使集群不稳定。
## 44.创建的临时节点什么时候会被删除，是连接一断就删除吗？
ZooKeeper的临时节点（Ephemeral node）在创建该节点的客户端与ZooKeeper的连接断开时**会被自动删除**。

具体来说，当创建临时节点的客户端会话因超时或主动关闭而中止时，或者某个客户端（不一定是创建者）主动删除该节点时，临时节点就会被删除。连接断开之后，ZooKeeper不会立即删除临时数据，只有当SESSIONEXPIRED之后，才会把这个会话建立的临时数据移除。因此，用户需要谨慎设置SessionTimeout。
## 45.Zookeeper 能否为临时节点创建子节点？
**Zookeeper不允许为临时节点创建子节点**。

这是由于Zookeeper的设计特性，仅当创建临时节点的会话存在时，该节点才存在。会话失效后临时节点则被自动删除。基于这种特性，Zookeeper在设计时不允许临时节点拥有子节点。
## 46.请列举ZooKeeper中使用watch的注意事项有哪些？
在ZooKeeper中使用watch需要注意以下几点：

1. Watches通知是一次性的，必须重复注册。这意味着如果想要重新获取某个节点的watch通知，需要再次对该节点进行watch注册。
2. 在发生CONNECTIONLOSS之后，只要在session_timeout之内再次连接上（即不发生SESSIONEXPIRED），那么这个连接注册的watches依然在。这是因为在ZooKeeper中，客户端和服务端的会话在session_timeout时间内没有交互时，会话才会过期。
3. 节点数据的版本变化会触发NodeDataChanged。这里特意说明了是版本变化，而不仅仅是节点数据内容变化。只要成功执行了setData()方法，无论内容是否和之前一致，都会触发NodeDataChanged。
4. 对某个节点注册了watch，但是节点被删除了，那么注册在这个节点上的watches都会被移除。也就是说，如果一个节点被删除，那么之前注册在该节点上的所有watch都会被移除。
5. 同一个zk客户端对某一个节点注册相同的watch，只会收到一次通知。这意味着，如果同一个客户端多次注册相同的watch，那么该客户端只会接收到一次watch通知。
6. Watcher对象只会保存在客户端，不会传递到服务端。这意味着，当一个客户端接收到watch通知时，该通知只会在客户端进行处理，而不会传递给其他客户端。
7. 网络延迟或其他因素可能导致不同client在不同时刻获取watch事件和操作返回值。这意味着，不同的客户端可能会在不同的时间接收到watch通知和操作返回值。

总的来说，使用ZooKeeper中的watch功能时需要注意一些特定的情况和限制，以确保其能够正确地工作并实现预期的功能。
