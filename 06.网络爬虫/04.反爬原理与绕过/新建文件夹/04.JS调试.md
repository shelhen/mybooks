## 04.JS调试

了解`js`执行的顺序和逻辑，快速定位关键`js`代码，高效实现扣代码或是补环境，具体操作包括：反调试、`hook`技术定位变量、断点和跟栈及`webpack`导出`js`代码。

原则上，我们希望在尽可能少改动原本`js`代码的情形下实现响应的功能和逻辑，一方面，对方服务器的代码有可能随时变动，花费大量力气重构对方代码，一旦对方切换代码，又需要重写，非常麻烦；另一方面，我们希望在花费较少资源的前提下相对较快的获得加密参数，通过驱动浏览器来实现参数逆向比较慢，因此比较适中的增删`js`的方式是比较恰当的选择，而且在处理`js`代码时应该保持一个原则：**尽可能不改动或少改动`js`代码实现参数获取。**

### 一、关键参数定位

#### 1.全局搜索

浏览器工具栏中可以对当前加载内容进行全局搜索，该搜索可以解决绝大多数关键参数的定位问题，除了单纯的搜索变量名称之外，还可以在变量名称后增加`name:`/`name=`/`.name`/`['name']`/`["name"]`等方法进行进一步搜索，或者搜索一些`xhr`发包的`api`接口，还可以针对一一些揭秘特征进行搜索，如`base64`加密的`js`包中一定会包含如下字段，如`abdcef`、`123456789`、`1732584193`、`271733879`、`1732584194`、`271733878`。

#### 2.断点与跟栈

在定位到加密代码之后，为了精准的扣出关键代码或是更好的补充浏览器环境，可以通过断点和跟栈进一步细致的分析`js`的运行流程和结果，**加密函数一般位于明文密文之间。**

##### 1）方法栈

方法栈是指`js`重点方法时存储在栈空间中，对于方法而言一般都是先运行的方法最后被释放，栈空间也有变量先进后出的特点，因此可以通过函数方法的栈空间排序来判断函数之间的相互调用情况，在浏览器的方法栈中，最下方的方法是最先运行的，上方的方法时候来被调用的，通常上方方法运行结束后下方方法才能开始，可以根据方法栈可以得知参数加密的过程。

> 浏览器调试工具中资源面板`thred`处和`network`中`initiator`处都可以观察程序的栈调用情况。

> 官方的`js`包一般肯定不是加密函数所在的位置，加密函数一般一定在自己写`js`代码中。

跟值：直接点击方法栈内的方法，可以在几个方法之间来回跳，可以据此跟踪一个加密参数的变化情况。

##### 2）断点分类与实现

浏览器中的断点具有以下种类`dom`断点、`dom`事件断点、`xhr`断点、代码行断点、全局事件断点、`cavas`断点和异常捕获断点几类，以下是他们的一些定义和特性：

| 断点名称         | 性质                                                         | 操作                                                         |                                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| dom断点          | 当其节点属性发生变化或被js动态操作时才会进行断住。           | 在元素页面，右键可以为其添加断点                             | 一般对于加密参数的定位比较准，执行距离靠前，但是距离加密函数很远，无法进行跟踪堆栈，很难快速定位。 |
| dom事件断点      | 触发事件时会断住，一般用来给网页提交按钮/点击事件下断点      | 在元素页面，事件监听处直接给关键位置下断点。                 | 体上特性和dom断点一样，但是比他好一点，因为有的请求是表单发送的。 |
| xhr断点          | 发包函数执行发包时会被断住，但是只能是xhr包的才能打断点，表单发包不能断住。 | 根据对url的关键词的筛选下断点。                              | 位置靠后，定位的位置在发包函数附近，容易跟栈。               |
| 代码行断点       | 代码逻辑执行到该语句时会被断住。                             | 在一些关键js代码之前鼠标左键单击即可下断点，或者使用钩子函数，或替代js文件后，其中关键位置添加`debugger`语句断点。 |                                                              |
| 如下全局事件断点 |                                                              |                                                              |                                                              |
| cavas断点        | 滑动滑块时间会被断住。                                       | 滑块验证码，在创建验证码之前断点，便于分析验证码的生成过程。 |                                                              |
| load断点         |                                                              | 在dom加载之前断点，然后添加钩子函数                          |                                                              |
| 异常捕获断点     | 找浏览器指纹时，尤其是跟浏览器环境时，跟值时用来断点         | 勾选异常，分析代码到底try走还是expect路，更容易看到哪里try了，哪里缺少环境？ |                                                              |

##### 3）跟栈技巧

**搜索到可能的结果先给他加个断点，断点只能打在可能结果之前的语句处，不要打在方法定义处，应该打在方法调用处。**

> 比较好的地方，如`var`，`return`，方法调用之处，代码调试处黄色的都是系统方法，紫色的都是关键字，按住`ctrl`可以显示或者隐藏变量的值。

断点成功，说明我们找到了参数加密位置，找到了参数加密位置后，然后先逐步运行直到看到参数加密结果，看其方法栈找到关键代码，并进行分析。

```
promise：异步
stringfy（）json化
反括号前面的一定是方法()
两个括号之间的用逗号分隔的一定是参数。
object（obj）:obj一般是个方法，object（obj）等价于obj
```

#### 3.注入与`hook`

` Hook`方法是指替换原方法为自定义方法，在不改变原方法执行逻辑的基础上，附加一些其他内容，`python`中封装了装饰器可实现快速的钩子函数，而在`Js`中可以这样定义`hook`函数。

```js
function say(){
	console.log('我是xx')
}
say()
// 覆盖原函数
say = function(){
    console.log('我是hh')
}
say()

// 建议的思路,先把原方法存起来在改变
var hhsay = say  // 此时。我们修改hhsay后，调用hhsay就是我们的修改的方法，调用say还能使用原方法。
```

> 一些浏览器环境方法也可以hook函数，如`tostring()`、`clear()`、`setInterval()`。

##### 1）`Hook`原理

在`js`中实现`hook`主要利用了两点，第一是js中定义的变量可以直接赋值给其他变量，即使是一些局部变量也可以通过在其销毁之前通过转化为全局变量的方式存储，通过这一操作我们可以迅速复制原变量；第二则是`js`对象存在一些内部属性如`get`/`set`属性，`get`属性对应 `getter `函数，如果没有` getter`，则为 `undefined`，当访问该属性时，会调用此函数，执行时不传入任何参数，但是会传入` this` 对象（由于继承关系，这里的` this` 并不一定是定义该属性的对象），该函数的返回值会被用作属性的值。**set**：属性的` setter` 函数，如果没有` setter`，则为 `undefined`，当属性值被修改时，会调用此函数，该方法接受一个参数，也就是被赋予的新值，会传入赋值时的` this` 对象。`js`中也提供了许多函数实现对对象属性的修改`Object.defineProperty(obj, prop, descriptor)`、`new Proxy()`或`Function.prototype.constructor`，这里以`Object.defineProperty(obj, prop, descriptor)`为例，它可以直接作用与一个对象，增加或修改其现有属性，它接收三个参数：`obj`：需要定义属性的当前对象；`prop`：当前需要定义的属性名；`descriptor`：属性描述符，可以取以下值：

|     属性名     |   默认值    | 含义                                         |
| :------------: | :---------: | :------------------------------------------- |
|     `get`      | `undefined` | 存取描述符，目标属性获取值的方法             |
|     `set`      | `undefined` | 存取描述符，目标属性设置值的方法             |
|    `value`     | `undefined` | 数据描述符，设置属性的值                     |
|   `writable`   |   `false`   | 数据描述符，目标属性的值是否可以被重写       |
|  `enumerable`  |   `false`   | 目标属性是否可以被枚举                       |
| `configurable` |   `false`   | 目标属性是否可以被删除或是否可以再次修改特性 |

```js
(function() {
    //严谨模式 检查所有错误
    'use strict';
    //document 为要hook的对象   这里是hook的cookie
	var cookieTemp = "";
    Object.defineProperty(document, 'cookie', {
		set: function(val) {
				console.log('Hook捕获到cookie设置->', val);
				cookieTemp = val;
				return val;
		},
		get: function()
		{
			return cookieTemp;
		}
    });
})();
```

这里我们修改`cookie`变量的`set`属性，当其他方法为调用`cookie`的`set`即为其增加值时，我们直接输出`cookie`，这样就实现了一个简易的钩子。

##### 2）hook目的与作用

- 快速定位加密参数

**在`js`调试中我们常常需要寻找关键参数、关键代码的位置，如果通过浏览器的全局检索，找不到关键参数时，我们或许会尝试寻找发包函数，下`xhr`断点，通过发包函数定位关键参数或加密代码，如果有些加密代码不进行发包或者距离发包函数比较远呢？**难道需要一行一行读代码，找参数嘛？这时我们就可以通过`hook`函数修改变量或者函数的部分属性，一旦代码对其进行变动，就下断点`debugger`或者输出内容，帮助我们实时检测关键参数和调试关键代码，从而快速摸清代码的运行逻辑，轻松拿出关键代码。

- 处理服务器检测

这一点将在反检测处来具体说。

- 提供加密参数的外部接口

上一节使用驱动浏览器拦截原本网站的`js`文件，在其中加入新的语句并执行返回结果的方式，实质上也是一种`hook`手段。

##### 3）hook需要注意的地方

- `hook`一般用于`Hook`关键变量，而很难直接`hook`加密函数，但加密函数的定位一般在关键参数附近，可通过关键参数的栈调用寻找加密参数。
- `hook`一般用来`hook`全局变量/全局函数，局部变量很难`hook`，如果需要的话，可以最好精准断点后再`hook`。
- `hook`是有时机的，`hook`函数应在参数变化之前注入，如果参数仅使用一次，变化之后的注入将毫无作用。

##### 4）hook的几种方式

- 控制台`console`注入

也可以在浏览器的`console`处直接进行代码注入，当我们触发事件时影响关键参数时，就会触发hook函数，但是这种方式一旦浏览器刷新就会失效。

- `TamperMonkey `注入

`TamperMonkey `俗称油猴插件，是一款免费的浏览器扩展和最为流行的用户脚本管理器，支持很多主流的浏览器，可以说是跨平台的浏览器应用了，功能众多且强大。具体使用可以参见**以前的笔记**。如可以使用以下代码实现`cookie-hook`

```js
// ==UserScript==
// @name         Cookie Hook
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  Cookie Hook 脚本示例
// @author       shelhen
// @match        *
// @icon         https://www.******.com/img/favicon.ico
// @grant        none
// @run-at       document-start
// ==/UserScript==

(function () {
  'use strict';
  var cookieTemp = '';
  Object.defineProperty(document, 'cookie', {
    set: function (val) {
      if (val.indexOf('__dfp') != -1) {
        debugger;
      }
      console.log('Hook捕获到cookie设置->', val);
      cookieTemp = val;
      return val;
    },
    get: function () {
      return cookieTemp;
    },
  });
})();
```

- 浏览器插件注入

浏览器支持安装第三方扩展插件，可以自己制作一个帮助hook的浏览器插件即可，浏览器插件的编写并不复杂，以 Chrome 插件为例，只需要保证项目下有一个` manifest.json` 文件即可，它用来设置所有和插件相关的配置，必须放在根目录。其中 `manifest_version`、`name`、`version` 3个参数是必不可少的，如果想要深入学习，可以参考Google 官方文档或小茗同学博客，注意火狐浏览器插件不一定能在其他浏览器上运行，如下代码可以实现一个Chrome 浏览器 Hook 插件：

新建 manifest.json 文件：

```js
{
    "name": "Cookie Hook",          // 插件名称
    "version": "1.0",               // 插件版本
    "description": "Cookie Hook",   // 插件描述
    "manifest_version": 2,          // 清单版本，必须是2或者3
    "content_scripts": [{
        "matches": ["<all_urls>"],  // 匹配所有地址
        "js": ["cookie_hook.js"],   // 注入的代码文件名和路径，如果有多个，则依次注入
        "all_frames": true,         // 允许将内容脚本嵌入页面的所有框架中
        "permissions": ["tabs"],    // 权限申请，tabs 表示标签
        "run_at": "document_start"  // 代码注入的时间
    }]
}
```

新建 cookie_hook.js 

```js
var hook = function() {
    'use strict';
    var cookieTemp = '';
    Object.defineProperty(document, 'cookie', {
        set: function(val) {
            if (val.indexOf('__dfp') != -1) {
                debugger;
            }
            console.log('Hook捕获到cookie设置->', val);
            cookieTemp = val;
            return val;
        },
        get: function() {
            return cookieTemp;
        },
    });
}
var script = document.createElement('script');
script.textContent = '(' + hook + ')()';
(document.head || document.documentElement).appendChild(script);
script.parentNode.removeChild(script);
```

将这两个文件放到同一个文件夹，打开 chrome 的扩展程序, 打开开发者模式，加载已解压的扩展程序，选择创建的文件夹。

> 以上两种方式比较操作便捷，且能控制`hook`函数注入的时间一定在参数生成之前，但是有可能会被服务器通过浏览器指纹检测到这些插件。

- `Fiddler` 插件注入

使用fiddlers注入，让所有请求走代理通道，必要时甚至可以直接拦截修改必要的代码进行，这种方法最稳健，但是比较麻烦。

#### 4.内存漫游

内存漫游即借助一些工具随意检索chrome内存中存储的所有数据，这时目前比较有效的参数定位方式，与前面的断点定位调试不同，之前是通过变量名 key 来进行定位，而它是通过变量值 value 为特征进行定位，原理是在响应内容经过存储处理后，通过 Hook 方法来对内存中的数据进行监控。由于变量值一般为密文，因此在一次网站活动中很可能是唯一的，因此可以迅速定位到生成参数的位置，可参考。

https://gitee.com/wangpeng35023502/ast-hook-for-js-RE

https://github.com/JSREI/ast-hook-for-js-RE

通过设置Anyproxy代理服务器拦截响应，并通过AST 实时处理，让所有涉及变量改动地方都经过 Hook 方法，这样所有变量值的改动都可以捕获并保存到一个变量数据库中。接下来就能根报变量值搜索到存储这个字符串的变量及变量所在的代码位置，hook.search("")，单击代码位置可以自切换到Source 面板并自动定位到变量位置。

### 二、反调试

服务器反爬的一种手段是防止浏览器端对`js`代码进行注入/调试或加大客户端的代码调试难度，下面可以了解一下当我们进行浏览器调试时，后端通过什么方式检测到前端的代码调试以及如何加大调试难度的理论。

#### 1.调试特征

服务器可以通过使用`js`代码检测客户端是否按下`F12`键和禁止`F12`的方式检测用户是否调试过/正在调试。

服务器可以检测特定客户端的窗口内高度差来检测用户是否（调试过）处于调试状态。

浏览器环境中有特定变量`开发者人员工具`属性如果为`true`，则说明客户端正在调试。

正常用户不会调用`console.log()`方法，因此可以通过检测该方法被调用的次数和频率来检测客户端是否被调试过。

调试时要花费时间，经过调试后获取响应与正常响应时间不一，因此服务器可以检测从用户触发事件到调用发包函数之间的时间差来检测客户端是否经过调试。

当我们将鼠标放置在某方法或变量前面时，实际上`js`解释器在内部调用不停地调用`tostring()`方法，如果客户端在不停地调用`tostring`，说明正在调试，服务器也可以`hook`自己的代码来检测这一行为。

服务器方可以检测栈的层数caller（注意这里不通过浏览器调试，通过`hook`代码调用其`caller`方法来看起堆栈。）

还可以检测非浏览器环境(如`node`中 `global/host=127.0.0.1`）、检测`js`代码是否被格式化过，检测当前编码环境等，服务器检测客户端是否调试的方法有很多，这里只能列举部分。

#### 2.服务器的反调试

服务器会通过一些手段避免`js`代码被客户端调试，具体而言分为以下几种类型，第一，服务器无论你是否进行调试都直接加大`js`代码的调试难度；第二，服务器检测到了客户端的调试行为，因此采取了一些具体的措施直接阻止我们进行调试；服务器检测到了客户端的调试行为，但是不显式的采取措施，而是悄咪咪地堆满客户端内存或者将用户的调试路径引导到错误的分支逻辑。

```
代码混淆/无限debugger/禁用console/域名锁定/内存占用/暗桩/守护进程
具体堆内存的方法:死循环;无限递归;两个方法相互调用卡死;多线程堆内存;无限大的URL；函数中传如超长参数；历史记录写满；
守护进程：一个进程想办法让我们debugger/占用内存,另一个进程添加一个定时器，每隔一段时间就开启那个进程。
```

因此在调试的时候我们要注意这些`	for(;;)/while(true)/setinterval()/`语句，另外由于暗桩的存在，我们要以拿到加密参数为目的，如果拿不动就有可能哪里错了。

#### 3.处理反调试

对于代码混淆的处理下一节将会详细谈，这里学习几种简单反调试手段的处理方法，上文分析可知绝大多数的反调试行为可能存在以下关键语句：`debugger`、`for`、`while`、`setinterval()`。

- 如果代码未混淆——可以在本地环境中看到变量名称，还是可以通过`hook`来解决，**hook是解决该问题比较好的方案，尤其是使用`fd`等软件的hook，对该种方法的反爬只能通过在`js`中增加判断函数来检测，但是检测函数本身也可以被hook。**

- 如果对以上关键字进行了代码混淆，并将混淆代码置于虚拟机`（直接在eval()/Function()）`中调用，这时就比较复杂了，这是可以检索`eval`或`Function`关键字在代码混淆之前处理这些关键字——虚拟机中调用显示`js`的名字`VM789...`。

  我们可以直接让这个`eval()/Function()`不运行，这就带来一个问题，如果我们希望代码段中仅仅是`debugger`语句无法运行，而不是整个代码（其中包含一些正常功能）都无法运行，这种方式就不行。

  拿到构造函数中的参数，如果参数是明文的，对参数进行判断，如果参数中存在我们不想要的关键词，就可以替换为空或者替换为空格。

  ```js
  Function.prototype.constructor = function (X){
      if(X!=='debugger'){
          return AAA(X)
      }
      else {
          return function (){}
      }
  }
  ```

> 一般只能去修改其混淆之前的代码，混淆后的代码很难处理，如果动态的话就更头疼了。【瑞数(两层混淆动态混淆`js`)】

对于`debugger`语句还有以下常用的处理手段：直接选择跳过当前语句/取消浏览器全局调试（就直接不能调试）/编辑debugger为false/替换代码。

